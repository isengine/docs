# Основные понятия и термины

## isEngine

isEngine - это общее название системы. Происходит от слов "is" (это) и "engine" (движок). Созвучно с "easy" (простой, легкий).

Мы намеренно используем именно такое написание - слитно, со строчной буквы "i" и заглавной "E". Заглавная "I" (i) в некоторых шрифтах похожа на строчную "l" (L). Использование заглавной буквы в начале может создать неверное прочтение. Заглавная "E" внутри слова позволяет отделить слово "Engine" от слова "is".

В Вашем языке такое написание может быть неграмотным, но с точки зрения программирования, такое написание соответствует стилю "Camel case" и не является ошибкой.

## Система

Под словами "isEngine" и "система" мы подразумеваем весь программный комплекс. На самом деле он, конечно, состоит из множества компонентов, в том числе из сторонних библиотек и пользовательского кода.

Однако когда мы говорим о нем, как о едином целом, мы используем слова "система" или "isEngine".

При этом мы не подразумеваем конечный продукт - сайт или веб-приложение.

## Архитектура системы

Если рассматривать архитектуру системы, то нам представляется башня с такими уровнями:

* веб-сайт или веб-приложение
* система
* фреймворк
* язык программирования

Готовый продукт - это вершина башни, цель, то, ради чего все создавалось. Однако он использует систему в качестве каркаса.

В центре системы находится ядро, которое всей системой управляет. Это ядро, в свою очередь, построено с использованием набора инструментов - фреймворка, который уже разработан для определенного языка программирования.

Здесь мы хотим отметить, что мы воспринимаем фреймворк как набор инструментов для создания движка системы, а не как сам движок.

## Еще один фреймворк

Да, это лирическое отступление.

На самом деле, при проектировании системы заново, была мысль использовать существующий фреймворк. Однако требованиям к формату представления, обмена и обработки данных существующие фреймворки не удовлетворяли.

Таким образом в isEngine появился собственный микро-фреймворк, который Вы также можете взять за основу, или использовать в своем проекте в качестве библиотеки.

## Ключевое слово 'системные'

В дальнейшем руководстве будут часто упоминаться "системные данные" и "системные объекты".

Дело в том, что в самом начале нужно четко выделить определенную категорию данных из всего множества их видов. Слово "системный" хоорошо подходит для определения этой категории.

В первую очередь это те данные, которые соответствуют формату, принятому в isEngine. Точно так же, как и объекты.

## Форматы файлов

Разрешенных форматов файлов всего два:

* **.ini** - для хранения данных в формате **json**
* **.php** - для всех остальных файлов системы

Все классы, системные файлы и страницы шаблонов используют расширение **php**.

Все файлы данных имеют расширение **ini**.

Безопасность системы подразумевает то, что злоумышленник не может получить прямого доступа к чтению и изменению этих файлов. Поэтому на доступ к этим файлам можно установить ограничения.

## Формат путей для файлов и папок

В isEngine существует два правила для обозначения абсолютно всех путей.

Формат путей для папок **всегда** должен заканчиваться закрывающим слешем.

Формат путей для папок и файлов **никогда** не должен начинаться со слеша.

Также не забывайте использовать в **URL** слеш **[/]**, а в путях файловой системы сервера - константу **DS**!

Пример для папок:

	folder       # неправильно
	/folder      # неправильно
	/folder/     # неправильно
	folder/      # правильно

Пример для файлов:

	folder/      # правильно
	/folder.php  # неправильно
	/folder.php/ # неправильно
	folder.php/  # неправильно

Эти правила могут не соответствовать правилам файловой системы, но их соблюдение позволяет избежать ошибок при составлении пути.

Пример для PHP:

    $folder = 'folder/';
    $path = DR . $folder . 'file.php';
    echo $path;

Результат:

    ...directory_root/base/path/folder/file.php

Пример для URL:

    $page = 'page.html';
    $folder = 'folder/';
    $path = 'https://site.com/' . $folder . $page . '?one=a';
    echo $path;

Результат:

    https://site.com/folder/page.html?one=a

**Внимение!** Пример ошибки:

    $page = '/page.html';
    $folder = '/folder/';
    $path = 'https://site.com/' . $folder . '/' . $page . '?one=a';
    echo $path;

Результат:

    https://site.com//folder///page.html?one=a

Как видите, нарушение этих правил ведет к печальным последствиям, постоянной необходимостью следить за переменными и чистить пути от множественных слешей.

## Формат URL

Любой **URL** должен соответствовать принятому стандарту

Разберем следующий пример:

    http://site.com/path/to/page.html?one=1&two=2#name

Данный **URL** состоит из следующих частей:

* http              # scheme, схема запроса
* site.com          # host, адрес хоста (сайт, домен)
* path/to/page.html # path, путь
* one=1&two=2       # query, параметры запроса
* name              # fragment, фрагмент

К сожалению, фрагменты **URL-запроса** не распознаются на стороне сервера. Так что при разборе **URl-запроса** поле фрагмента всегда будет пустым.

Каждый **URL** представляет собой запрос к какому-либо ресурсу. В первую очередь, **URL** идентифицирует этот ресурс. Здесь используются **схема** (scheme), **адрес** (host) и **путь** (path) запроса.

Но **действия** или **методы** не являются ресурсом. Чтобы совершить какое-либо **действие**, нам нужно обратиться к серверу. Другими словами - составить запрос. **Параметры** (query) как раз составляют параметры этого запроса.

Запрос может состоять из **заголовков** - чисто служебной информации и **тела** - собственно, содержимого этого запроса.

Сервер отвечает на запрос таким же образом. В **тело** ответа включается содержимое страницы (для сайта), либо другая предоставляемая сервером информация. Это могут быть служебные коды, либо сообщение об ошибке.

Протокол **HTTP** определяет следующие **методы**:

* GET - получает полные данные (**тело** и **заголовки**)
* HEAD - получает только **заголовки** (служебную информацию)
* POST - отправляет данные на сервер
* PUT - отправляет запрос на создание нового ресурса на сервере, либо на замену существующего
* PATCH - отправляет запрос на изменение фрагмента ресурса
* DELETE - отправляет запрос на удаление ресурса
* CONNECT - устанавливает постоянную двунаправленную связь (туннель) с сервером
* OPTIONS - отправляет запрос на получение параметров соединения
* TRACE - отправляет запрос, и получает его обратно для сравнения (например, какую информацию промежуточные серверы добавляют или изменяют в запросе)

**Методы** **GET**, **HEAD** и **OPTIONS** считаются безопасными, потому что по установленному стандарту вызов этих методов состояния ресурса (данных на сервере) не изменяет. Остальные - нет. Поэтому сервер должен обязательно их проверять.

По-умолчанию **методы** **GET** и **HEAD** кэшируются, остальные - нет. Поэтому при использовании **метода** **POST** можно быть уверенным, что запрос выполнится. В случае с **GET** Вы можете получить ответ из кэша, так что запрос напрямую до сервера может и не дойти.

Некоторые серверы могут вообще не принимать определенные **методы**.
