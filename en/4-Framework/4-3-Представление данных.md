# Представление данных

**Системные данные** принципиально отличаются от прочих данных форматом хранения и правилами их обработки.

**Системные объекты** являются результатом преобразования таких данных.

## Формат системных данных

**Системные данные** хранятся в виде строк.

В строке возможно разбиение данных на элементы через двоеточие **[:]** и на группы через прямую черту **[|]**.

Например, такая строка

    "group:item1:item2"

будет представлена в таком виде:

    {
      "group" : [ "item1", "item2" ]
    }

А такая строка

    "group1:item1:item2|group2:item3:item4"

будет представлена в таком виде:

    {
      "group1" : [ "item1", "item2" ],
      "group2" : [ "item3", "item4" ]
    }

## Упрощенный режим

При парсинге данных по-умолчанию включен **упрощенный режим**.

В этом режиме система старается воспринимать данные без учета групп.

Например, такая строка

    "group:item1:item2"

будет представлена уже в таком виде:

    [ "group", "item1", "item2" ]

А такая строка

    "group1:item1:item2|group2:item3:item4"

будет представлена в таком виде:

    [
      [ "group1", "item1", "item2" ],
      [ "group2", "item3", "item4" ]
    ]

## Формат системных объектов

Работа с **системными объектами** всегда подразумевает под собой, что перед нами находится ассоциативный массив, даже если это простой массив. Порядок следования данных в простом массиве считается в таком случае ключами этого массива.

Например, такой простой массив

    ['a', 'b', 'c']

будет воспринят системой так:

    [
      0 => 'a',
      1 => 'b',
      2 => 'c'
    ]

Он также может быть представлен в виде строки:

    { "0":"a", "1":"b", "2":"c" }

**Системный объект** воспринимается именно как массив, а не как объект или класс. Любой объект при работе с ним именно как с **системным объектом**, должен быть преобразован в ассоциативный массив. Это значит, что все свойства будут преобразованы в ключи, а все методы - проигнорированы.

Например, такой объект

    {
      'one'   => 'a',
      'two'   => 'b',
      'three' => 'c'
    }

будет воспринят системой так:

    [
      'one' => 'a',
      'one' => 'b',
      'one' => 'c'
    ]

И он также может быть представлен в виде строки:

    { "one":"a", "two":"b", "three":"c" }

В строковом представлении **системные объекты** хранятся в формате **json**, незначительно доработанном для лучшего взаимодействия с пользователем.

* разрешены отступы строк в виде пробелов и табуляций
* разрешены переносы строк '\r', '\n' и '\r\n'
* разрешены комментарии вида '//' до конца строки
* разрешены комментарии вида '/*...*/'

Такие объекты преобразуются обратно в ассоциативные массивы.

## Флаг пропуска

Восклицательный знак в начале строки в **системных данных** воспринимается как флаг, отвечающий за пропуск этих данных.

Например, наличие восклицательного знака впереди элемента означает, что данный элемент будет пропущен:

    "group:!item1:item2"

Результат:

    { "group" : [ "item2" ] }

Наличие восклицательного знака впереди группы означает, что будет пропущена вся группа:

    "!group1:item1:item2|group2:item3:item4"

Результат:

    { "group2" : [ "item3", "item4" ] }

Также флаг пропуска работает в **системных объектах**:

    { "group1" : [ "!item1", "item2" ], "group2" : [ "!item3", "item4" ] }

Результат:

    [
      "group1" => [
        "item2"
      ],
      "group2" => [
        "item4"
      ]
    ]

Однако, настройки парсинга позволяют не учитывать этот флаг. Такой подход оставлен для управления настройками, например, в панели администрирования.

## Текстовые переменные

Формат системных данных позволяет использовать текстовые переменные. Их вызов по-умолчанию осуществляется через фигурные скобки:

    {name:attribute1:attribute2:...}

Однако Вы можете использовать любой другой определитель. Например, двойные фигурные скобки:

    {{name:attribute1:attribute2:...}}

Текстовые переменные преобразуются в нужные строки через отдельную функцию.

## Формат чисел

Числа могут быть представлены в виде целых чисел **(int)**, чисел с плавающей точкой **(float)**, либо в виде строки **(string)**. Все эти три вида относятся к типу **numeric**.

В isEngine числа проверяются на соответствие типу **numeric**.

Ноль и единица также воспринимаются как числа.

> Будьте аккуратны с этим, так как в ряде случаев проверка на true/false сработает не так, как обычно!

## Формат даты и времени

Для запроса даты и времени используются те же обозначения, которые приняты в стандарте **ISO 8601**.

* YYYY - год, 4 знака: 2019
* MM - месяц, 2 знака, с нулем: 01-12
* DD - день, 2 знака, с нулем: 01-31
* hh - часы, 24-часовой формат, с нулем: 01-24
* mm - минуты, с нулем: 00-59
* ss - секунды, с нулем: 00-59

Однако мы расширили и дополнили их:

* YY - год, 2 знака: 19
* M - месяц, 1-2 знака, без нуля: 1-12
* D - день, 1-2 знака, без нуля: 1-31

* yy - год, 4 знака: 2019
* y - год, 2 знака: 19
* nn - месяц, 2 знака, с нулем: 01-12
* n - месяц, 1-2 знака, без нуля: 1-12
* dd - день, 2 знака, с нулем: 01-31
* d - день, 1-2 знака, без нуля: 1-31
* ww - день в году, 0-365
* w - день недели, 1-7

* h - часы, 24-часовой формат, без нуля: 1-24
* gg - часы, 12-часовой формат, с нулем: 01-12
* g - часы, 12-часовой формат, без нуля: 1-12
* m - минуты, с нулем: 00-59
* s - секунды, с нулем: 00-59

* p - префикс: am/pm
* z - временная зона, в миллисекундах: от -43200 до 50400

* aa - абсолютное время, число секунд и миллисекунд с эпохи UNIX
* a - абсолютное время, число секунд с эпохи UNIX

Кроме того, можно использовать следующие названия:

* year - год, 4 знака: 2019
* month - месяц, 2 знака, с нулем: 01-12
* day - день, 2 знака, с нулем: 01-31
* hour - часы, 24-часовой формат, с нулем: 01-24
* min - минуты, с нулем: 00-59
* sec - секунды, с нулем: 00-59
* msec - миллисекунды, с нулем: 000-999

* ampm - префикс: am/pm
* week - номер недели в году, 1-42
* days - число дней в месяце: 28-31
* zone - временная зона, двоеточие между часами и минутами: +02:00

* abs - абсолютное время, число секунд с эпохи UNIX

Для вызова любого из перечисленных форматов, используются фигурные скобки, как в текстовых переменных.

Например:

    {day}.{month}.{year} {hour}:{min}

Результат:

    31.12.2019 23:59

## Коллекции и записи

**Запись** (entry) - это набор данных, снабженных служебной информацией.

Сами данные представляют собой **системный объект** и могут быть абсолютно произвольного вида. Служебная информация строго типизирована. Она включает:

* id - порядковый номер
* name - имя записи
* type - тип записи
* parents - родители
* ctime - время создания записи
* mtime - время последнего изменения записи
* dtime - время "конца жизни" записи
* owner - владельцы
* data - данные в формате json

**Порядковый номер** служит для учета и проставляется автоматически. А вот **имя записи**, в отличие от номера, используется для идентификации записи. Это непохоже на большинство других систем, где идентификация записей идет по полю **id**.

Поле **тип записи** сделано специально для того, чтобы по нему можно было искать и фильтровать записи. Оно носит чисто служебный характер и не требует обязательного заполнения. Записывается в формате системных данных. Т.е. значение может быть преставлено строкой или массивом.

Поле **родители** похоже на **тип записи**, но служит для создания многоступенчатой иерархии записей. Это похоже на папки в файловой системе или на разделы в пространстве имен.

Поля времени служат для фильтрации и сортировки записей. Например, запись не может быть доступна для публикации, если ее **время создания** еще не подошло, или **время конца жизни** уже прошло.

Поле **владельцы** содержит идентификаторы пользователей, которые являются авторами записи, или имеют на нее полные права собственности.

Поле **data** как раз и содержит произвольные данные, которые распознаются системой как **системный объект**.

**Коллекция** представляет собой набор **записей**.
