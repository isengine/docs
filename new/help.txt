=================
Структура системы
=================

Слои:

* сайт или веб-приложение (фронтэнд)
* серверная часть, система управления (бэкэнд)
* движок
* фреймворк
* язык, интерпретатор

Фреймворк представляет собой набор инструментов, на базе которого сделан движок.

Движок же, в свою очередь, управляет системой. Именно движок строится по модели MVC или другой,
именно он принимает запросы и отвечает на них. Именно он обеспечивает контроль доступа к данным,
вывод информации и многое другое.

Для чего же нужен слой фреймворка?

В основе любой системы лежат данные, а сама система, по сути, просто управляет доступом к ним.
В расширенном виде это выглядит как чтение, запись и обмен (прием и передача), обработка и вывод
данных на экран устройства пользователя. Пользователи распределяются по группам и для разных групп
действуют разные ограничения на работу с данными.

Когда мы говорим за систему, мы подразумеваем множество правил, и самые главные - правила работы с
данными. Фреймворк, являясь прослойкой между системой и языком программирования, представляет все
необходимые инструменты для работы с данными согласно этим правилам. Обратный момент состоит в том,
что используя фреймворк, вы принимаете эти правила.

Таким образом, фреймворк задает правила работы с данными и дает все необходимые инструменты.

Движок - это собранная на базе фреймворка система, с которой и предстоит работать. Ее можно изменять
и настраивать, расширять и дорабатывать, подключать различные модули и библиотеки. Именно движок
является сердцем системы.

Отличие движка от фреймворка в том, что фреймворк не является готовым продуктом, а лишь набором
инструментов. Его нельзя конфигурировать. Также фреймворк задает правила, которым движок вынужден
подчиняться.

При разработке можно отказаться от движка системы и написать свой. Можно также использовать несколько
фреймворков совместно. Но это может быть не слишком разумно.

Фреймворк постоянно дорабатывается, а движок стремиться стать достаточно гибким для того, чтобы на
его базе можно было легко создавать любые веб-приложения.

====================
Структура фреймворка
====================

Фреймворк сделан на базе архитектуры MVC (модель-представление-контроллер) с тонким контроллером и
без реализации View.

Для создания представления предлагается свой набор инструментов, но конкретная реализация представления
ложится на разработчика. Так, можно осуществлять вывод через php, использовать любой доступный
шаблонизатор или создать свой.

Контроллер осуществляет лишь прием и разбор данных, поступивших от пользователя. Затем эти данные
передаются в модель.

Модель отвечает не только за работу с базой данных, но за обработку любых данных вообще. По-настоящему,
модель здесь - это комплекс различных моделей по работе с данными.

То, что именно в модели, а не в контроллере, как обычно, сосредоточена вся бизнес-логика, наиболее точно
согласуется с принципами MVC.

Также все три компонента логически максимально изолированы друг от друга. Например, модель ничего
не знает о работе контроллера или представления и наоборот. Даже внутри модели вложенные компоненты
не контролируют работу друг друга. Они обмениваются данными в общем формате и могут использовать общие
функции и способы обработки. Но это является соблюдением правил, а не нарушением изолированности.

На данный момент обособленно стоят еще два компонента фреймворка. Это функции-помощники и js-адаптер.

Функции это еще одна дополнительная прослойка внутри фреймворка, находящаяся в самом низу, над языком
программирования. Часть функций можно отнести к вспомогательным, однако по-настоящему они служат для
того, чтобы фреймворк можно было достаточно безболезненно портировать на любой язык программирования.
Поэтому функции здесь - это помощники.

Эти помощники сделаны в виде статических методов объектов, что позволяет вызывать их без создания
экземпляра объекта. С другой стороны, они распределены в пространстве имен, что исключает конфликты
с другими классами, библиотеками, фреймворками и самим языком. Также функции инкапсулированы в классы
для упрощения синтаксиса кода.

Js-адаптер представляет собой код помощников, написанный на javascript. По названию, входящим данным и
результату они полностью идентичны работе помощников на php. Целью их создания было обеспечить работу
фреймворка на JavaScript.

=================
Пространство имен
=================

Верхним рабочим пространством имен является

> /is/

В него вложены разделы, согласно структуре фреймворка

> /is/Model/
> /is/View/
> /is/Controller/
> /is/Helpers/

Отдельный раздел предусмотрен под движок

> /is/Engine/

И еще один раздел выделен под приложение

> /is/App/

Подразделы строятся согласно внутренней архитектуре системы.

=============
Формат данных
=============

На самом деле, система работает с одним форматом данных - ассоциативным массивом.

Данные в нем хранятся в виде:

> 'ключ' : 'значение'

Однако для хранения и передачи используется еще два формата данных.

* JSON,
* собственный строковый формат

JSON является доработанным, со следующими отличиями от оригинала:
* разрешены отступы строк в виде пробелов и табуляций
* разрешены переносы строк '\r', '\n' и '\r\n'
* разрешены комментарии вида '//' до конца строки
* разрешены комментарии вида '/*...*/'

Собственный формат может использоваться даже внутри JSON или внутри значения массива. Это данные
вида:

> 'ключ:значение1:значение2|другой_ключ:значение1:значение2'

Такое представление будет распознано следующим образом:

> { ключ : [значение1, значение2], другой_ключ : [значение1, значение2] }

Также допускается использовать только значения, без ключей:

> 'значение1:значение2:значение3:значение4'

Такое представление будет распознано следующим образом:

> [ значение1, значение2, значение3, значение4 ]

Все эти форматы преобразуются в итоге в ассоциативный массив.

Непустой ассоциативный массив и строка со спецсимволами ':' и/или '|' распознаются функциями-помощниками
как системные данные.

Данные с ключом или значением, содержащими в начале восклицательный знак, будут распознаны системой как
заблокированные и будут пропущены при чтении. Это относится к данным, переданным в любом виде.

> 'ключ:значение1:!значение2|!другой_ключ:значение1:значение2'
> {"ключ":["значение1","!значение2"],"!другой_ключ":["значение1","значение2"]}

=========================
Формат данных в коллекции
=========================

Rоллекция является группой данных, собранных вместе по какому-либо признаку. По-сути коллекция представляет
собой массив. База данных также является одним из видов коллекции.

В коллекции каждым данным присваивается запись, имеющая следующие обязательные поля:

> id | name | type | parents | ctime | mtime | dtime | self | data

В большинстве полей разрешены только латинские буквы, цифры и ряд допустимых символов (,-_). Следующие символы
относятся к нежелательным, использование их допускается, но может вызывать проблемы (:| .!). Сюда же относятся
буквы национальных кодировок.

Восклицательный знак может создать проблемы с блокировкой записи. Пробел и точка в ряде полей будут распознаны
как разделители. Двоеточие и прямая черта не допускаются к использованию в файловой системе Windows. Буквы
национальных кодировок могут быть некорректно преобразованы при переносе между кодировками.

* id - порядковый номер записи в коллекции, целое число
* name - имя записи, восклицательный знак в начале имени записи не включит ее в коллекцию при чтении.
* type - тип данных, для поиска и фильтрации определенных данных внутри одного раздела
* parents - родительские группы, может быть указано несколько групп через разделитель
* self - это поле содержит идентификаторы пользователей или групп, которые являются авторами или последними,
кто вносил изменения, может быть указано несколько идентификаторов через разделитель
* ctime - время создания записи в формате метки unix
* mtime - время последнего изменения записи в формате метки unix
* dtime - время окончания действия записи в формате метки unix
* data - данные

=============
Формат файлов
=============

Разрешенных форматов файлов всего два:

* php для страниц
* ini для данных

Все страницы, включая системные и страницы шаблонов, используют расширение php.

Все файлы данных имеют расширение ini.

Локальные данные могут быть представлены в виде коллекций. В этом случае имя файла интерпретируется следующим
образом:

> /(parents.../)(id.)name(.type)(.self1 self2).ini

Идентификатор определяется в том случае, если он является числом и у файла есть имя. Точки заменяют разделители
полей, пробелы - разные записи в поле, если поле такое допускает.

К сожалению, с передачей точек, например, в имени файла, непременно возникнут проблемы. Поэтому специальные
символы в имени файла можно экранировать, заключив в квадратные скобки:

> /(parents.../)(id.)my[.]name(.type)(.self[ ]1 self[ ]2)(.dtime).ini

Поля в скобках можно не указывать. Но если вам нужно пропустить значение в поле, поставьте разделяющую точку:

> /parents.../id.my[.]name...dtime.ini

Теперь значение поля будет пустым.

Значения полей ctime и mtime берутся из информации о файле.

==================
Конструктор данных
==================

Обычно данные представлены в виде ассоциативного массива. Однако, с помощью конструктора, вы можете создать
объект, который будет содержать указанные вами данные в виде свойств. Такой объект будет иметь обязательный
набор данных, и если каких-нибудь данных в массиве не окажется, свойство будет присутствовать в объекте, но
будет либо пустым, либо иметь значение по-умолчанию.

Но главной особенностью конструктора является подготовка данных. Например, конструктор позволяет создавать
новые свойства, склеивая данные из разных ячеек массива. Или преобразовывать строковые данные в массив по
заданному разделителю.

============
Формат путей
============

Фреймворк использует две константы для путей:

* DS - это разделитель папок, синоним константы DIRECTORY_SEPARATOR, которая автоматически определяет тип
правильного разделителя папок в файловой системе - '/' или '\'
* DP - указывает на путь верхнего уровня, это синоним '..' и константы DIRECTORY_SEPARATOR

Когда часть пути содержится в переменной, используются два основных правила. Формат путей для папок всегда
должен заканчиваться закрывающим слешем. Формат путей для папок и файлов никогда не должен начинаться со слеша.

* 'folder\' - единственный правильный формат
* 'folder' - неправильно
* '\folder' - неправильно
* '\folder\' - неправильно

Следуя этим правилам, в пути никогда не будет двойных слешей или пропуска слешей. Одну часть пути всегда будет
легко пристыковать к другой. Также легко можно будет использовать как абсолютный, так и относительный путь.

=========================
Список функций-помощников
=========================

================
Иерархия классов
================

Globals - классы объектов, реализованные через родительский класс 'Singleton' (синглтон). Эти классы заменяют
глобальные объекты. Форма вызова:

> use is\Model\Globals\ClassName;
> $class = ClassName::get();

Managers - классы управления глобальными объектами, реализованные через родительский абстрактный класс 'Manager'.

Свойства:

* auto - разрешает запускать автоматически инициализацию и сохранение данных (get, initialize, set) при создании
экземпляра класса
* name - задает имя глобального класса, которым менеджер будет управлять
* data - массив, копирующий свойства глобального класса

Методы:

* get() - копирует данные из глобального класса, задан по-умолчанию, запускается в конструкторе
* set() - сохраняет данные в глобальный класс, задан по-умолчанию
* initialize() - инициализирует разбор данных в классе, должен быть реализован в каждом конкретном менеджере






