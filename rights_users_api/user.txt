Работа с пользовательской частью сайта происходит по аналогии с работой админки.

Существует всего 4 куки для идентификации пользователей:

SID - session id, сейчас назначается при входе пользователя на сайт, с открытием сессии
	по-идее, должен задаваться только при авторизации пользователя
AID - administrator id, назначается при авторизации пользователя в админке
UID - user id, назначается при авторизации пользователя в пользовательской части сайта
PID - private id, назначается при заходе пользователя в приватную часть сайта

пользовательская часть сайта задается константой NAME_PERSONAL
приватная часть сайта задается константой NAME_PRIVATE

Константы также используются для роутинга и формирования путей. Например, если NAME_PERSONAL задан как "my",
то шаблон пользовательской части сайта будет также называться "my", а сама пользовательская часть сайта
будет доступна по адресу http://site.com/my/. То же самое с NAME_PRIVATE

Пользовательская часть сайта служит для того, чтобы сделать разграничить доступ к сайту и сделать, например,
личный кабинет с корзиной покупок, подписками и новостями.

Приватная часть служит для разграничения прав и доступов для различных пользователей, например для платного
доступа по подписке, для создания раздела для продавцов и т.п.

Тем не менее, приватная часть является расширением пользовательской части, а не является отдельной частью сайта.
Это означает, что доступ к приватной части сайта происходит также через авторизацию пользователя, когда
пользователь получает UID, и только затем система распознает, обладает ли пользователь необходимыми правами,
и если да, то назначает ему PID.

Таким образом возможны только следующие сочетания кук:
	SID
	SID + AID
	SID + UID
	SID + UID + PID


Про использование AID и админской части сайта см. соответствующий раздел.

На данный момент система идентификации ползьователей работает через куки. Имеет ли смысл использование сессий?

Однозначного ответа нет. Сессии сбрасываются по истечении некоторого времени и при выходе пользователя с сайта.
Конечно, это дает некоторую степень защиты, но с другой стороны использование кук более дружелюбно, т.к. при
повторном заходе пользователя на сайт, ему не потребуется авторизация. Также открыт вопрос о целесообразности
использования обоих механизмов.

Сессии используются для элементарной проверки источника запроса. Например, в файле "verification.php", если
не задано использование баз данных, открывается сессия и записывается переменная сессии. Далее идет проверка
серверных переменных источника запроса на соответствие их имени сайта, а в числе прочего - наличие переменной
сессии. Если же одно из условий неверно, запрос считается опасным, все данные сбрасываются и скрипт прекращает
работу. Все сделано хорошо, в том числе то, что куки можно подделать, да и ответ сервера тоже, при большом желании,
но сессию уже очень сложно, т.к. она находится на стороне сервера и для этого нужен доступ к нему посредством
взлома. Странно только то, что запись переменной сессии и ее проверка происходят в том же файле. Т.е. вроде бы как
теряется смысл - можно просто отключить проверку и все.



Помимо кук и констант путей используются константы проверок.

Важно помнить, что константу можно подделать и отправить запрос с другого сайта, а потому она не должна являться 100% гарантией.
Однако константы можно и нужно использовать как элемент базовой защиты, а также для подтверждения каких-либо условий.

Проверка любой константы имеет вид: "defined('is...') or die;", где "is..." - имя константы.

isCMS - самая первая константа, задается в корневой папке, в файле "index.php"
	нужна для проверки любой php страницы сайта на принадлежность CMS и является базовой защитой
	если в начале страницы сделать проверку вида "defined('isCMS') or die;", то страница не будет грузится
	при простом запросе из браузера вида "http://site.com/page.php", если же проверки не будет, то страница загрузится
	и все ее содержимое будет выведено, зачастую с ошибками, что отменяет роутер, защиту сайта и наверняка вовсе не нужно
		\index.php (назначение)

isADMIN - константа доступа в админку, назначается при запросе страницы входа в админку вида "http://site.com/administrator/"
	нужна только лишь для того, чтобы не повторять для входа в админку обработчик шаблона, путей и прочего,
	а перевести обработку на общую загрузку через индексную страницу и затем по проверке дополнить шаблон
	по-сути, своего рода кольцо, схема подробно описана в соответствующем разделе
		\administrator\index.php (назначение)
		\includes\templates.php (проверка)

isQUERY - константа препроцессора запросов, назначается при вызове препроцессора, т.е. по сути при формировании
	правильного запроса к сайту, согласно инструкции (см. разделы процессы и препроцессор)
	и является базовой защитой при проверке любого запроса, при этом в запросе даже не обязательно делать проверку на isCMS,
	т.к. процессор ничего не выводит (кроме ошибок), а является только обработчиком и вызывается через "index.php"
	(!на данный момент из всех процессов не содержат isQUERY только процессы payment)
		\includes\preprocessor.php (назначение)
		\includes\processor\...\....php (проверка)

isORIGIN - константа, которая подтверждает добропорядочность источника, является по большей части также базовой защитой
	используется в разных частях сайта, осталась со старой версии и непонятно, в каком виде будет присутствовать сейчас
		\includes\verification.php (проверка и назначение)
		\includes\verify\ban.php (проверка)
		\includes\processor\user\activation.php (назначение)

isHACK - константа, которая идентифицирует запрос как потенциально опасный
	используется в разных частях сайта, осталась со старой версии и непонятно, в каком виде будет присутствовать сейчас
		\includes\verification.php (назначение)
		\includes\verify\ban.php (проверка)
		\includes\processor\user\restore.php (проверка)



На данный момент авторизация сделана как общий процесс для пользователя и для админа. Для этого достаточно вывести форму с
параметром query=authorisation. В разделе users базы данных существует поле status, которое имеет цифровое значение.
Любое цифровое значение до 100 интерпретируется как пользовательские права, а 100 и выше - админские.
Эти значения в дальнейшем, при построении сайта со сложной структурой, могут пригодиться для разграничения различных прав пользователей.
Например, редакторов, модераторов, простых и привелигированных участников.

При этом, однако, через одну и ту же форму можно заходить как пользователям, так и администраторам. Однако же если вы
хотите ограничить доступ, достаточно ввести в поле всего один параметр:
	data[onlyadmin] - для входа только администраторов, попытка входа пользователя, даже с верным логином/паролем, будет
	интерпретирована как неверная
	data[onlyuser] - аналогично, только для пользователей

\includes\processor\user\

activation.php
deactivation.php
restore.php

регистрация будет идти по аналогии с прошлой регистрацией
ссылаемся на файлы:
c:\OSPanel\domains\0mm.ru\www\includes\processor\forms\
	registration.php
	sendmail.php
	
и еще, переменные для регистрации и авторизации разные,
потому что форма входа и форма регистрации - на одной странице

тут нам тоже их придется разделять, либо по id-шнику, либо по типу и конечно по query -> name

и еще!
надо бы вынести все базы в папку security, а не administrator,
которая может располагаться вне структуры, например, на уровень или несколько уровней выше папки www,
ну или какая там будет папка установки
тогда авторизацию в админку можно сделать также через запрос:
site.com?query=administrator
фиг кто догадается

?query=administrator&data%5Blogin%5D=123&data%5Bpassword%5D=123



dbUse, dbSelect - это функции работы с базой данных пользователя
ну и разобраться с функциями из файлов data.php/old.php в папках mysqli/pdo:
	old.php - старые версии файлов для работы с бд, сейчас нигде не используются и не подгружаются
	data.php - подгружаются вместе с functions.php, но что там - надо разбираться


параметры бд users задаются через файл/раздел userstable:

	"name" : "",
	// название поля
	// в данный момент убрано, а название поля перенесено в ключ всего раздела
	
	"type" : "",
	// numeric / boolean / date / string or false
	// тип поля - число/да-нет/дата/текст
	// это значение используется для обработки данных функцией dataclear($data, $type)
	
	"validation" : "",
	// string or false
	// тип проверки поля в функции datavalidation
	
	"unique" : true,
	// true/fasle
	// уник - да/нет, должно ли значение быть уникальным для этого поля
	
	"required" : true,
	// true/fasle
	// обязательно - да/нет, является ли заполнение этого поля обязательным условием
	
	"secure" : false,
	// true/fasle
	// защита - разрешено ли добавлять это поле в данные пользователя после авторизации или удалять его после авторизации,
	// таким образом оно будет недоступно для взлома после авторизации пользователя
	// для чего нужно защищать поля? например, можно защищать пароль и логин - от взлома, id пользователя, его статус
	// неважно, что пользователь в дальнейшем будет делать на сайте, этих данных нигде в системе не будет
	// таким образом, логин и пароль будут доступны только на момент авторизации. Защиту таких данных, как день рождения,
	// телефон, тоже не обязательно светить, зато их можно использовать для сбора статистики, рассылки подарков
	// другие данные, которые могут выводиться пользователю, или которые будут использоваться в дальнейшем, можно просто закриптовать
	
	"crypt" : false,
	// true/false/hash/password
	// кодирование - да/нет, являются ли данные в этом поле кодированными:
	// true - кодировка по-умолчанию функцией datacrypt($data)
	// hash - данные в виде хэша, формируемые функцией datacrypt($data, 'hash')
	// для функции datacrypt применяется собственный алгоритм шифрования, который впоследствии может меняться,
	// а при желании его можно перепрограммировать самому
	// password - внутренний алгоритм хэширования паролей функцией password_hash,
	// для проверки нужно использовать функцию password_verify
	
	"readonly" : false,
	// true/fasle
	// только чтение - да/нет, разрешена ли запись в это поле,
	// проверка по этому параметру используется при вызове функции записи/редактирования данных пользователя
	// как это можно реализовать? посылать в опции who id или логин пользователя, система проверит его статус,
	// и если статус позволяет делать данную операцию, то она будет совершена, иначе - отклонена
	
	"system" : ""
	// string or false
	// системное определение поля, доступные значения:
	// authorise - логин, поле, по которому разрешена авторизация
	// password - пароль, поле, хэш которого проверяется при заполнении
	// dateregister - дата и время регистрации / ctime
	// datelastvisit - дата и время последнего визита / mtime
	// allow - статус бана
	// allowip - список разрешенных ip
	// allowagent - список разрешенных устройств/браузеров

Поля по-умолчанию.
Без указания этих полей, база данных пользователя выдаст ошибку.

// идентификатор пользователя
"id" : {
	"secure" : true, // рекомендуемый параметр
	"readonly" : true // рекомендуемый параметр
},

// логин
"login" : {
	"required" : true, // обязательный параметр
	"unique" : true, // обязательный параметр
	"secure" : true, // рекомендуемый параметр
	"readonly" : true // рекомендуемый параметр
},

// пароль
"password" : {
	"required" : true, // рекомендуемый параметр
	"secure" : true, // рекомендуемый параметр
	"crypt" : password, // рекомендуемый параметр
	"readonly" : true // рекомендуемый параметр
},

// статус доступа к приватному разделу
"status" : {
	"secure" : true, // рекомендуемый параметр	
	"readonly" : true // рекомендуемый параметр
},

// поле данных пользователя в формате json
// здесь может быть множество данных из профиля, которые открываются только пользователю
"data" : {
}



Если при регистрации пользователя есть поле, в конец названия которого добавлено слово "_confirm", то такое поле
требует проверки с полем, не имеющим этого слова.

Если поле имеет статус уникального и при этом оно закриптовано, то проверка уникальности ведется двумя способами.
Для более легкого и быстрого способа в таблице должно присутствовать поле с тем же названием, но со словом "_hash" в конце.
Тогда идет сравнение по хэшу. Если же такого поля нет, то проверка идет по сравнению закриптованного значения с каждым полем
путем раскодирования обоих значений и их сравнения. Это необходимо, потому что при криптовании в результат вносится набор
случайных данных, таким образом, несколько результатов криптования одного и того же слова никогда не будут одинаковыми.
Соответственно, такой способ является долгим и ресурсозатратным, поэтому для таких полей рекомендуется добавлять в настройки
еще одно поле.



!!! Нужно добавление поля _hash при записи в базу данных, но ДО сравнения с настройками usertable, чтобы лишние поля все-таки обрезались

!!! Нужно сделать форму активации и вообще весь режим активации