Процессор - это обработчик процессов, который занимается проверкой входящих данных и их перераспределением

В файле 'processor.ini' перечисляются зарегистрированные в системе процессы и их обработчики (процессоры)

Пример структуры файла:

{
	"settings.administrator:system" : null,
	"language.administrator" : null,
}

Формат процесса задается таким образом:

	name.parent:type

Существует четыре типа процессов:

	system - системные, для которых всегда разрешена запись в базу данных, даже если по-умолчанию или для текущего пользователя она запрещена
	custom - обработчик процесса находится в кастомной папке
	module - обработчик процесса находится в папке модуля
	остальные, либо пустой тип - для них, как впрочем и для system, обработчик процесса находится в папке ядра

Система вызывает процессы при запросе пути url, первая часть которого соответствует константе DEFAULT_PROCESSOR. Дальнейшие части url разбираются как родитель, имя процесса и его статус:

	site.com/processor/parent/name/status?query

Если будет вызван процесс, отсутствующий в списке или будет отсутствовать файл обработки процесса, то сайт вернет ошибку 403: неверный запрос

Все остальные данные передаются через параметры post или get. В принципе, не запрещены и другие методы запросов, такие как put, head и прочие, но как они будут интерпретированы системой - это вопрос.

Все эти данные будут собраны процессором в один системный объект $process со следующей структурой:

	method
		string
		метод передачи данных - post или get, причем всегда маленькими буквами, т.к. при получении, значение метода конвертируется в маленькие буквы
	set
		object
		объект, содержащий информацию о базовых значениях запроса:
		
		name
			string
			имя запроса, так же название процесса
		parent
			string
			родитель запроса, по-сути папка для группировки однотипных запросов
		param (! заменен на parent)
			string
			параметр запроса, чаще всего это параметр модуля, с которым он был вызван
		status
			string
			статус запроса, например для платежа это может быть fail - ошибка и success - успешно
			будьте внимательны (!) если задан статус, то обработчик будет пытаться загрузить процессор с таким же именем
		type
			string
			тип запроса - см. выше
		path
			string
			путь для вызова обработчика запроса, заменяет устаревший open
		
	hash
		string
		хэш запроса, собственно это время, закриптованное базовой функцией для проверки времени запроса
		время жизни запроса устанавливается константой SECURE_PROCESSTIME
		если время запроса было больше, чем время его жизни (например, более 10 минут назад), то запрос считается устаревшим и система выдаст ошибку
		для тестирования запросов можно использовать фейковый запрос, состоящий из 10 любых знаков и символа '=' вначале, например '=1234567890' или '=qwertyuiop',
		но это работает только в режиме разработки
	csrf
		string
		хэш запроса для защиты от CSRF взлома
		активен только при включенной константе SECURE_CSRF
	data
		array
		массив сопутствующих данных
		передается через $_POST/GET['data'], например:
		$_POST['data']['name'], $_POST['data']['password'], $_POST['data']['email']
	open (! удален)
		string
		адрес вызываемого процессора
		формируется в обработчике
	close
		true/false
		прервать дальнейшую загрузку сайта после вызова данного процесса или нет, особенно полезен при ajax запросах
		назначается через $_POST/GET['close']
		будьте внимательны (!) любое непустое значение обрабатывается как true, любое пустое значение, а также 0 или отсутствие обрабатывается как false
	errors
		array
		массив, содержащий ошибки
	var
		array
		массив переменных, необходимых для обработки данных процессором
		по окончании обработки он чистится, так что если нужно сохранить какие-либо данные, передавайте их либо через data, либо через errors

Базовый шаблон модуля форм формирует правильный запрос с хэшем и всеми данными

Данные из строки в любом случае преобразуются в массив с ключом 'default': ...&data=text >>>>>>>> $process -> data['default'] => 'text'
Чтобы передать массив данных, например ['id' => 1, 'name' => 'user', 'type' => 'description'] он должен выглядеть так: ...&data[id]=1&data[name]=user&data[type]=description

Что еще важно - name и status подвергаются обработке и по-сути являются безопасными. Однако data обработке не подвергается, и может содержать в себе все, что угодно.
Поэтому в процессоре важно будет обрабатывать получаемые данные, сравнивать их с допустимыми и отбрасывать лишние

Процессор - вызываемый обработчик того или иного события (процесса), например, регистрации или авторизации пользователя, отправки сообщений и т.п.

Обшие процессы собраны в одну группу и ими по-сути должен заниматься один процессор. Но на данный момент это не так.
В этой версии процессор, грубо говоря, представляет собой название папки, в которой содержится набор процессоров, каждый из которых заточен только под одно событие

Введение переменной $process позволяет упорядочить поток входящих данных и в дальнейшем стандартизировать и укрепить систему процессов



Теперь в системе появились защищенные процессы. Эти процессы подвергаются дополнительной проверке. Защита процессов настраивается через установки процессов. Так, в базе данных процессу вместо значения 'null' нужно задать ассоциативный массив настроек защиты.

После этого система защиты запоминает пользователя по ряду параметров, даже неавторизованного, и в другие разы она пытается его идентифицировать. В первую очередь это защита от спама, накрутки голосования, множественного автозаполнения форм и т.д. Конечно, можно обмануть систему защиты, сменив ip-адрес и подпись 'agent' браузера, однако система предусматривает определенные виды борьбы с этим, а также в дальнейшем система идентификации будет совершенствоваться.

На данный момент поддерживаются следующие настройки:

	count
		numeric
		задает число разрешенных вызовов процесса для одного пользователя
	clear
		numeric/string
		устанавливает время, после которого происходит очистка счетчика вызовов
		например, таким образом можно ограничить число попыток авторизации 10, по истечении которых доступ к процессу для данного пользователя будет заблокирован, например на 1 час
		запись поддерживает либо абсолютный формат времени в секундах, либо текстовую запись в формате данных 'num:time'
	pause
		numeric/string
		устанавливает паузу между вызовами
		если время между вызовами одного и того же процесса одним и тем же пользователем меньше заданной паузы, то процесс не запускается, а вместо этого завершается ошибкой
		задается либо число секунд либо время в формате данных 'num:time', например '5:minute'
	time
		numeric/string
		устанавливает время жизни запроса
		если указано, то работает вместо SECURE_PROCESSTIME
	authorised
		true/false
		разрешает доступ к процессу только авторизованным пользователям
		определяет статус пользователя по $user -> uid
		если вам нужно более гибко управлять правами разных групп пользователей, то это необходимо делать через права доступа к базе данных и проверку прав внутри процессора-обработчика
	close
		true/false
		устанавливает, что делать с системой после завершения процесса - закрыть или продолжить загрузку
		раньше загрузка продолжалась с места вызова процесса, но это было связано с вызовом процессов только по параметрам запроса
		теперь запуск процессов осуществляется через раздел в адресной строке, что является правильным с точки зрения архитектуры сети (рекоммендации стандартов)
		однако теперь же невозможно возобновить загрузку системы, т.к. в этом случае она неизбежно приведет к ошибке в роутере (код 404), т.к. запрошенный адрес существует только для процессов
		поэтому в случае, если система не закрывается после загрузки, она автоматически перезапускается с самого начала по предыдущему адресу ($uri -> previous) с сохранением параметров адресной строки ($uri -> query -> string)
		это свойство можно использовать в процессах, чтобы изменять, либо дополнять адрес и параметры
		для традиционной схемы обработки это, конечно, увеличивает нагрузку на систему, т.к. после выполнения процесса ее приходится перезапускать заново с прохождением всех проверок
		однако есть и большой плюс, например, защита доступа к базе данных, которая по-умолчанию (вне процессов) закрыта для записи
		если же вы используете ajax, то перезапуск системы не потребуется, только вам нужно помнить, что ajax процессы всегда должны закрываться после завершения, иначе вы получите вместо нужных данных целый код страницы сайта

Другая особенность защищенных процессов в том, что они обязательно записывают обращения пользователей к процессам.

Эти обращения хранят в данных только число вызовов и время последнего вызова, в имени - md5-хэш идентификатора пользователя (id - НЕ UID или SID - для авторизованных и pid для авторизованных), а также в родителях - родитель и имя процесса.

Все обращения хранятся в разделе базы данных 'attempts'. Но их запись идет до разрешения на запись в базу данных. И даже если бы она шла после, есть ситуации, когда запись в базу данных не разрешается. Все это привело к тому, что в драйвере добавились необходимые условия при проверке прав и доступа для разрешения записи в раздел 'attempts'.



Для работы с модулями была введена приоритетная проверка процессов.

Это сделано для того, чтобы во-первых, изолировать процессы модуля от процессов системы.
А во-вторых, если злоумышленник попывается взломать системный процесс через модуль, то ему будет до него труднее добраться.
Аргумент, конечно, слабый, но тем не менее он есть.

Как работает приоритет. Все просто - если $process -> name соответствует названию модуля, а также если в модуле есть файл
обработчика processor.php, то процессор переключает обработку на него.



Формы, соответственно, должны выглядеть так:

<form method="post" id="form" action="/process/name/"> // или get - неважно
								// идентификатор формы необходимо указывать, если вы хотите связать с этой формой вынесенные за ее пределы элементы
								// например, тэг button после закрытия формы
								// атрибут action должен содержать адрес процессора и имя процесса, адрес лучше всего задавать через константу: action="/<?= DEFAULT_PROCESSOR; ?>/name/"
	(!) устарело:
	<input type="hidden" name="query" value="process"> // здесь в value указать название процесса или модуля
	
	<input type="text" name="data[...]" value="..."> // дальше идут строки формы, где любые данные передаются через массив data, иначе они просто не будут учтены
	...
	
	<input type="submit" value="submit"> // кнопка отправки данных на сервер
	<button type="submit">button name</button> // или так
	<button type="submit" name="data[...]">button name</button> // если добавить атрибут name, то с помощью этой кнопки можно также передать еще одни данные
</form>

<input type="text" form="form" name="data[...]" value="..."> // данные из этого поля также будут отправлены на сервер, т.к. поле связано через атрибут form с id формы
<button type="submit" form="form">button name</button> // эта кнопка также отправит данные формы на сервер, т.к. она связана через атрибут form с id формы
