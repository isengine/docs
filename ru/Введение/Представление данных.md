# Представление данных

Представление данных

# Системные константы

Это константы, зарезервированные системой. Они задаются при инициализации и являются общими для ядра и фреймворка.

  isENGINE - константа, определяющая систему. В ранних версиях использовалась как одно из средств защиты. Также хранит временную метку старта инициализации.

	DS - просто короткий синоним константы DIRECTORY_SEPARATOR из php, которая определяет слеш для файловой системы.

	DR - путь до корневой папки проекта в файловой системе. Назван от «directory root», по аналогии с «directory separator».

  DP - перемещение в родительскую папку, синоним "..DS". Назван от «directory parent».

# Области видимости

глобальной областью видимости для системы является

> /is/

Существует системная область

> /is/system/

В ней расположены глобальные системные объекты

$template
$router
$system
$query
$lang
$dictionary
$url

Есть также область видимости модулей, в которой работают модули

> /is/modules/

Еще одна область видимости - для контента, где расположены статьи, список статей или текущая статья

> /is/content/

Еще есть защищенная, скрытая область видимости, которая предназначена для хранения защищенных данных

> /is/secure/

И последняя область видимости - для администраторов, модераторов и прочих управляющих сайтом

> /is/administrator/

Системные константы не располагаются в какой-либо из этих областей видимости - они находятся в глобальной области видимости интерпретатора php и могут быть вызваны из любого места.

# Формат данных

Все данные хранятся в формате json, незначительно доработанном и специализированном системой.

Отличия:

разрешены отступы строк в виде пробелов и табуляций
разрешены переносы строк '\r', '\n' и '\r\n'
разрешены комментарии вида '//' до конца строки
разрешены комментарии вида '/*...*/'

Внутри данных возможно разбиение на атрибуты через двоеточие.

> "group:item1:item2"

Такие данные будут разобраны и представлены в виде:

{ "group" : [ "item1", "item2" ] }

Возможно перечисление через запятые, точки с запятыми и пробелы:

> "first:item1:item2,second:subitem1:subitem2"
> "first:item1:item2;second:subitem1:subitem2"
> "first:item1:item2 second:subitem1:subitem2"

Такие данные будут разобраны и представлены в виде:

{ "first" : [ "item1", "item2" ], "second" : [ "subitem1", "subitem2" ] }

Если вам нужно разделить значения внутри данных, то напишите их через знак точки "." - например:

> "group:item1.subitem1.subitem2:item2"

Такие данные будут разобраны и представлены в виде:

{ "group" : [ "item1.subitem1.subitem2", "item2" ] }

Строка "item1.subitem1.subitem2" разобрана не будет, т.к. через точку могут передаваться не только параметры, но и имена файлов с расширениями, и десятичные числа и текст.

Однако если вы знаете, что в данном конкретном случае будут передаваться именно параметры, вы можете их разобрать в дальнейшем коде.

Наличие восклицательного знака впереди ключа означает, что данный элемент будет целиком выключен и не будет разбираться:

{ "!first" : [ "item1", "item2" ], "second" : [ "subitem1", "subitem2" ] }

Так установлено по-умолчанию. Однако, эту особенность можно пропустить, что удобно, например, для управления настройками в панели администрирования.

Такое представление данных является понятным для пользователя и весьма удобным, например, для передачи атрибутов и аргументов.

Также формат данных поддерживает текстовые переменные, вызов которых осуществляется через фигурные скобки:

> {name:attribute1:attribute2:...}

Поддерживается ограниченное число текстовых переменных. На данный момент это:

link - для вывода ссылки
lang - для вызова языковой переменной
module - для вывода модуля в контенте
page - для вызова страницы в контенте

Дело в том, что по-умолчанию ссылки через тег <a> в контенте запрещены в целях безопасности и единственной возможностью
вывода ссылок в контенте является их вызов через текстовую переменную

Планируется также ввести переменные:

router - для получения данных страницы
content - для управления контентом
date - для вывода даты

Еще было бы неплохо сделать вывод через общую функцию, которая может выводить данные переменных, форматировать их (дата, телефон)
и использовать ее как прослойку для редактирования сайта через фронтэнд

# Форматы файлов

Разрешенных форматов файлов всего два:

- php для страниц
- ini для данных

Все страницы, включая системные и страницы шаблонов, используют расширение php.

Все файлы данных имеют расширение ini.

# Формат базы данных

Поля базы данных представлены следующими колонками:

	id | name | type | parent | ctime | mtime | self | data

	id - необязательно для файла, но обязательно для таблицы
	name - соответствует имени файла с расширением ini
	type - тип данных, для поиска и фильтрации определенных данных внутри одного раздела
	parent - родитель, к какому семейству относится эта запись, в случае локальной базы данных, это - название родительской папки
	ctime - время создания записи
	mtime - время последнего изменения записи
	self - это поле содержит идентификаторы пользователей, которые являются авторами или последними, кто вносил изменения
	data - данные в формате json

Отдельно стоит обратить внимание на то, что поля 'parent' и 'self' читаются как массив, что позволяет им хранить несколько значений. Так, для поля 'parent' это позволяет отследить всех родителей по всей глубине вложенности, а для поля 'self' это позволяет назначить нескольких владельцев.

Работа с базой данных осуществляется через функцию dbUse. Для каждого типа базы данных используется одинаковый формат вызова этой функции.

Непосредственно за работу функции отвечает драйвер. Это файл, в котором функция dbUse обращается непосредственно к базе данных и осуществляет определенные операции. Таким образом драйвер отвечает за работу с базой данных, проверку разрешений и прочее.

Локальная база данных представлена папками и файлами с расширением ini, в которых записаны данные в формате json. Все данные, которые хранятся в этиъ файлах, соответствуют данным в базе данных и могут быть перенесены из одного типа в другой.

Локальная база данных типизирована. Файлы могут быть двух видов:

	- файл строки (одна запись из раздела базы данных)
	- файл раздела (несколько записей, являющиеся разделом базы данных)

В содержимом файла параметры всегда разделяются через знак двоеточие ":". Однако значения полей также могут передаваться в имени файла. Так как имя файла не может содержать двоеточие, такие значения разделяются через знак точки "."

Например, для файла строки в локальной базе данных, имя файла и его расположение в файловой системе на сервере будут прочитаны следующим образом:

	/database/(parent/)(id.)name(.type.self1 self2)[.ext]

Значение полей ctime и mtime берутся из информации о файле, а значение поля data - это содержимое файла в формате json.

Если файл является файлом раздела, то здесь будут различия.

Файл раздела имеет следующее название:

	/database/name[.ext]

Содержимое представляет собой такую структуру:

	{
		"(id:)name(.parent)(:type:self1 self2)" : { data },
		...
	}
	
Как видите, это по-прежнему файл данных в формате json. Однако теперь значения полей, которые раньше были в имени файла, теперь перенесена в ключ. А значение поля data является содержимым данных с этим ключом.

Обратите внимание на то, что родитель должен быть разделен не двоеточием, а точкой.

Значение полей ctime и mtime по-прежнему берутся из информации о файле.

# Проверка

Проверка существования данных или положительного результата осуществляется через функцию set(), которая проверяет присутствие данных и возвращает true/false.

Она заменяет в большинстве случаев вызов isset() и !empty(), плюс многочисленные проверки вида:

if (empty($x) || $x === 0 || $x === '0')
if (!empty($x) && is_array($x) && reset($x))

и так далее. Подробнее см. в описании функции.

Вызов:

> if (dataset($x))

Проверка данных на соответствие массиву осуществляется через функцию dataarray().

Она заменяет в большинстве случаев проверки и конвертации вида:

if (is_array($x) || is_object($x))
if (is_object($x)) { $x = (array) $x; }

Вызов:

> if (dataarray($x))
> if (dataarray($x)) { $x = dataarray($x, true); }

# Ограничения

Структура не должна содержать элементы с одинаковыми названиями, даже если они находятся в разной вложенности:

	[х] нельзя              [v] можно
	...                     ...
	"group_one" : {         "group_one" : {
		"item"                  "item_one"
	},                      },
	"group_two" : {         "group_two" : {
		"item"                  "item_two"
	},                      },
	...                     ...

# Контент

Новый системный объект

$content

$content -> ...

name - имя текущего материала. Если вам нужно взять имя материала, берите его отсюда. Также $content -> this грузится по этому значению из базы. Также по этому значению проверяется тип текущей страницы в функции thispage().
this - массив, полные данные текущего материала.
page - номер страницы
all - true/false для всех
filter - параметры страницы из $template -> page['parameters']
list - массив, пока пустой, для загрузки сюда прочих материалов

# Вывод данных

Вызов данных, в том числе языковых, должен происходить через функцию dataprint().

	! ТОГДА И ТОЛЬКО ТОГДА выведенные данные будут БЕЗОПАСНЫ

Через эту функцию можно также выводить языковые переменные.

Подробный режим работы функции пока не установлен.

# Формат путей для файлов и папок

Для обозначения путей существует системный объект $uri который содержит всю информацию о запрошенном пути к сайту, а также производные от него, используемые в других системных объектах.

Структура $uri такая:

	{
		scheme
		// схема запроса
		// http, https
		
		host
		// хост или адрес сайта
		// может быть как с www, так и без
		
		path : {
			string
			// путь в виде строки
			
			array
			// путь в виде массива из папок
			
			file
			// файл, если был запрошен какой-нибудь файл
		}
		
		query : {
			string
			// запрос в виде строки
			
			array
			// запрос в виде массива, где ключи - имена полей запроса, а значения - данные полей запроса
		}

		www
		// служебный триггер
		// false - если хост сайта без www, true - если хост сайта с www
		
		site
		// полный адрес сайта
		// собранный заново из scheme и host
		
		url
		// полная строка запроса
		// может отличаться от изначального запроса, т.к. была разбита на части, прошла обработку и была собрана заново
	}

Еще есть константы NAME_FOLDER, PATH_FOLDER и URL_FOLDER, которые соответствуют всем системным папкам.

Например, для системной папки с кэшем (FOLDER cache) эти константы будут такими:

	NAME_CACHE = cache
	PATH_CACHE = server\site\cache\
	URL_CACHE  = /cache/

Для каждой константы в конфигурационном файле можно задать два значения:

	имя папки
	путь
	
Так, если путь НЕ будет пустой, он запишется в константы PATH_FOLDER и URL_FOLDER, однако NAME_FOLDER будет нетронута. URL_FOLDER не будет хранить пути, которые ведут выше корневой папки сайта.

Например, для системной папки с кэшем (FOLDER cache), если второе значение будет 'system/folder' эти константы будут такими:

	NAME_CACHE = cache
	PATH_CACHE = server\site\system\folder\cache\
	URL_CACHE  = /system/folder/cache/

А для значения '../folder' эти константы будут уже такими:

	NAME_CACHE = cache
	PATH_CACHE = server\folder\cache\
	URL_CACHE  = 

Формат путей для папок ВСЕГДА должен ЗАКАНЧИВАТЬСЯ закрывающим слешем:

	/ для url-ссылок
	DS для файловой системы внутри php-файлов

DS - это синоним константы DIRECTORY_SEPARATOR, которая автоматически определяет слеш в файловой системе - / или \

Формат путей для папок и файлов НИКОГДА не должен НАЧИНАТЬСЯ со слеша.

	folder\      - единственный правильный формат
	folder       - неправильно
	\folder      - неправильно
	\folder\     - неправильно
	folder.php   - неправильно
	\folder.php  - неправильно
	\folder.php\ - неправильно
	folder.php\  - неправильно

Формат путей должен НАЧИНАТЬСЯ со слеша только в КОНСТАНТАХ ПУТЕЙ:

	URL_FOLDER = \folder\

Таким образом, любой вызов будет записан следующим образом:

	$subfolder . $folder . $file
	PATH_FOLDER . $another_folder . $file
	URL_FOLDER . $another_folder . $file

НЕДОПУСТИМО использовать такие записи:

	$subfolder . '\' . $folder . '\' . $file
	PATH_FOLDER . DS . $another_folder . DS . $file
	URL_FOLDER . '/' . $another_folder . '/' . $file

потому что они могут привести к путям в таких форматах:

	subfolder/\folder/\file
	PATH_FOLDER\\another_folder\\file
	/URL_FOLDER//another_folder//file

Исключением является случай, когда вы используете переменную, содержащую какое-либо название и оно НЕ заканчивается на слеш. Однако, если вы используе переменную типа $folder, ее значение ДОЛЖНО заканчивается на слеш.

Имя сайта НЕЛЬЗЯ использовать вместе с PATH_FOLDER, но МОЖНО с URL_FOLDER, при этом будьте внимательными, чтобы не получилась запись с двумя слешами:

	'http://site.com' . PATH_FOLDER . another_folder даст http://site.com/\server\site\another_folder/ неправильно
	'http://site.com/' . URL_FOLDER . another_folder даст http://site.com//URL_FOLDER/another_folder/  неправильно
	'http://site.com' . URL_FOLDER . another_folder  даст http://site.com/URL_FOLDER/another_folder/   единственный правильный формат

# Формат URL

CSRF-Токены: https://habr.com/ru/post/318748/

https://habr.com/ru/company/yandex/blog/265569/

1. URL идентифицирует ресурс — некоторую разделяемую сущность. Файл — ресурс. Ручка, которая что-то ищет — ресурс. Вызов метода — не ресурс.
Если вы хотите шарахнуть из пушки по Луне, то вот так делать не надо:

	GET /?method=шарахнуть&to=Луна

Заведите ресурс «шарахалка», и тогда у вас всё будет логично:

	POST /шарахалка/?to=Луна

2. URL состоит из схемы (протокола), хоста, пути (path), запроса (query) и фрагмента.
Путь используется для организации иерархических ресурсов.
Запрос — для неиерархических ресурсов и для параметров операции.
Фрагмент идентифицирует подчинённый ресурс, не имеющий прямого URL.

Scheme      Host                 Path               Query      Fragment
  ↓           ↓                    ↓                  ↓            ↓
http://nyashnye-kotiki.xxx/breeds/maine-coon/?deliver_to=Moscow#photo

Если на вашем сайте «Няшные котики» есть каталог по породам,
то его вполне логично организовать в виде частей path,
поскольку каждый котик принадлежит ровно к одной породе.

А вот доставлять одного котика можно в несколько городов,
поэтому фильтр «с доставкой в город N» следует организовать через query.

3. Обращение по HTTP состоит из применения метода (глагола) к URL.
Результатом такого применения должно быть — сюрприз-сюрприз! — то, что в глаголе написано.
То есть GET возвращает представление ресурса, DELETE удаляет и т.п.

4. Методы GET, HEAD, OPTIONS — безопасные. Предполагается, что вызов этих методов состояния ресурса не изменяет.
Поэтому многие сетевые агенты — такие, например, как префетчер ссылок в браузере или мессенджере —
считают себя вправе по таким ссылкам ходить без явного волеизъявления пользователя. ИЧСХ, никаких стандартов не нарушают.

5. По умолчанию методы GET и HEAD кэшируются, OPTIONS, POST, PUT, PATCH, DELETE — нет.
Поэтому если вы шарахнули по Луне методом POST, вы можете быть (почти) уверены, что этот запрос выполнится.
Если вы шарахаете методом GET, какой-нибудь промежуточный прокси может ВНЕЗАПНО отдать вам ответ из кэша, и шарах в реальности не произойдёт.

