# Представление данных

Представление данных

# Системные константы

Это константы, зарезервированные системой. Они задаются при инициализации и являются общими для ядра и фреймворка.

  isENGINE - константа, определяющая систему. В ранних версиях использовалась как одно из средств защиты. Также хранит временную метку старта инициализации.

	DS - просто короткий синоним константы DIRECTORY_SEPARATOR из php, которая определяет слеш для файловой системы.

	DR - путь до корневой папки проекта в файловой системе. Назван от «directory root», по аналогии с «directory separator».

  DP - перемещение в родительскую папку, синоним "..DS". Назван от «directory parent».

# Области видимости

Начальной областью видимости для системы является

> is/

# Формат данных

Все данные хранятся в формате json, незначительно доработанном и специализированном системой.

Отличия:

разрешены отступы строк в виде пробелов и табуляций
разрешены переносы строк '\r', '\n' и '\r\n'
разрешены комментарии вида '//' до конца строки
разрешены комментарии вида '/*...*/'

Внутри данных возможно разбиение на атрибуты через двоеточие.

> "group:item1:item2"

Такие данные будут разобраны и представлены в виде:

{ "group" : [ "item1", "item2" ] }

Возможно перечисление через запятые, точки с запятыми и пробелы:

> "first:item1:item2,second:subitem1:subitem2"
> "first:item1:item2;second:subitem1:subitem2"
> "first:item1:item2 second:subitem1:subitem2"

Такие данные будут разобраны и представлены в виде:

{ "first" : [ "item1", "item2" ], "second" : [ "subitem1", "subitem2" ] }

Если вам нужно разделить значения внутри данных, то напишите их через знак точки "." - например:

> "group:item1.subitem1.subitem2:item2"

Такие данные будут разобраны и представлены в виде:

{ "group" : [ "item1.subitem1.subitem2", "item2" ] }

Строка "item1.subitem1.subitem2" разобрана не будет, т.к. через точку могут передаваться не только параметры, но и имена файлов с расширениями, и десятичные числа и текст.

Однако если вы знаете, что в данном конкретном случае будут передаваться именно параметры, вы можете их разобрать в дальнейшем коде.

Наличие восклицательного знака впереди ключа означает, что данный элемент будет целиком выключен и не будет разбираться:

{ "!first" : [ "item1", "item2" ], "second" : [ "subitem1", "subitem2" ] }

Так установлено по-умолчанию. Однако, эту особенность можно пропустить, что удобно, например, для управления настройками в панели администрирования.

Такое представление данных является понятным для пользователя и весьма удобным, например, для передачи атрибутов и аргументов.

Также формат данных поддерживает текстовые переменные, вызов которых осуществляется через фигурные скобки:

> {name:attribute1:attribute2:...}

Поддерживается ограниченное число текстовых переменных. На данный момент это:

link - для вывода ссылки
lang - для вызова языковой переменной
module - для вывода модуля в контенте
page - для вызова страницы в контенте

Еще было бы неплохо сделать вывод через общую функцию, которая может выводить данные переменных, форматировать их (дата, телефон)
и использовать ее как прослойку для редактирования сайта через фронтэнд

# Форматы файлов

Разрешенных форматов файлов всего два:

- php для страниц
- ini для данных

Все страницы, включая системные и страницы шаблонов, используют расширение php.

Все файлы данных имеют расширение ini.

# Формат базы данных

Поля базы данных представлены следующими колонками:

	id | name | type | parent | ctime | mtime | self | data

	id - необязательно для файла, но обязательно для таблицы
	name - соответствует имени файла с расширением ini
	type - тип данных, для поиска и фильтрации определенных данных внутри одного раздела
	parent - родитель, к какому семейству относится эта запись, в случае локальной базы данных, это - название родительской папки
	ctime - время создания записи
	mtime - время последнего изменения записи
	self - это поле содержит идентификаторы пользователей, которые являются авторами или последними, кто вносил изменения
	data - данные в формате json

Отдельно стоит обратить внимание на то, что поля 'parent' и 'self' читаются как массив, что позволяет им хранить несколько значений. Так, для поля 'parent' это позволяет отследить всех родителей по всей глубине вложенности, а для поля 'self' это позволяет назначить нескольких владельцев.

Работа с базой данных осуществляется через функцию dbUse. Для каждого типа базы данных используется одинаковый формат вызова этой функции.

Непосредственно за работу функции отвечает драйвер. Это файл, в котором функция dbUse обращается непосредственно к базе данных и осуществляет определенные операции. Таким образом драйвер отвечает за работу с базой данных, проверку разрешений и прочее.

Локальная база данных представлена папками и файлами с расширением ini, в которых записаны данные в формате json. Все данные, которые хранятся в этиъ файлах, соответствуют данным в базе данных и могут быть перенесены из одного типа в другой.

Локальная база данных типизирована. Файлы могут быть двух видов:

	- файл строки (одна запись из раздела базы данных)
	- файл раздела (несколько записей, являющиеся разделом базы данных)

В содержимом файла параметры всегда разделяются через знак двоеточие ":". Однако значения полей также могут передаваться в имени файла. Так как имя файла не может содержать двоеточие, такие значения разделяются через знак точки "."

Например, для файла строки в локальной базе данных, имя файла и его расположение в файловой системе на сервере будут прочитаны следующим образом:

	/database/(parent/)(id.)name(.type.self1 self2)[.ext]

Значение полей ctime и mtime берутся из информации о файле, а значение поля data - это содержимое файла в формате json.

Если файл является файлом раздела, то здесь будут различия.

Файл раздела имеет следующее название:

	/database/name[.ext]

Содержимое представляет собой такую структуру:

	{
		"(id:)name(.parent)(:type:self1 self2)" : { data },
		...
	}
	
Как видите, это по-прежнему файл данных в формате json. Однако теперь значения полей, которые раньше были в имени файла, теперь перенесена в ключ. А значение поля data является содержимым данных с этим ключом.

Обратите внимание на то, что родитель должен быть разделен не двоеточием, а точкой.

Значение полей ctime и mtime по-прежнему берутся из информации о файле.

# Формат путей для файлов и папок

Формат путей для папок ВСЕГДА должен ЗАКАНЧИВАТЬСЯ закрывающим слешем:

	/ для url-ссылок
	DS для файловой системы внутри php-файлов

DS - это синоним константы DIRECTORY_SEPARATOR, которая автоматически определяет слеш в файловой системе - / или \

Формат путей для папок и файлов НИКОГДА не должен НАЧИНАТЬСЯ со слеша.

	folder\      - единственный правильный формат
	folder       - неправильно
	\folder      - неправильно
	\folder\     - неправильно
	folder.php   - неправильно
	\folder.php  - неправильно
	\folder.php\ - неправильно
	folder.php\  - неправильно

Формат путей должен НАЧИНАТЬСЯ со слеша только в КОНСТАНТАХ ПУТЕЙ:

	URL_FOLDER = \folder\

Таким образом, любой вызов будет записан следующим образом:

	$subfolder . $folder . $file
	PATH_FOLDER . $another_folder . $file
	URL_FOLDER . $another_folder . $file

НЕДОПУСТИМО использовать такие записи:

	$subfolder . '\' . $folder . '\' . $file
	PATH_FOLDER . DS . $another_folder . DS . $file
	URL_FOLDER . '/' . $another_folder . '/' . $file

потому что они могут привести к путям в таких форматах:

	subfolder/\folder/\file
	PATH_FOLDER\\another_folder\\file
	/URL_FOLDER//another_folder//file

Исключением является случай, когда вы используете переменную, содержащую какое-либо название и оно НЕ заканчивается на слеш. Однако, если вы используе переменную типа $folder, ее значение ДОЛЖНО заканчивается на слеш.

# Формат URL

CSRF-Токены: https://habr.com/ru/post/318748/

https://habr.com/ru/company/yandex/blog/265569/

1. URL идентифицирует ресурс — некоторую разделяемую сущность. Файл — ресурс. Ручка, которая что-то ищет — ресурс. Вызов метода — не ресурс.
Если вы хотите шарахнуть из пушки по Луне, то вот так делать не надо:

	GET /?method=шарахнуть&to=Луна

Заведите ресурс «шарахалка», и тогда у вас всё будет логично:

	POST /шарахалка/?to=Луна

2. URL состоит из схемы (протокола), хоста, пути (path), запроса (query) и фрагмента.
Путь используется для организации иерархических ресурсов.
Запрос — для неиерархических ресурсов и для параметров операции.
Фрагмент идентифицирует подчинённый ресурс, не имеющий прямого URL.

Scheme      Host                 Path               Query      Fragment
  ↓           ↓                    ↓                  ↓            ↓
http://nyashnye-kotiki.xxx/breeds/maine-coon/?deliver_to=Moscow#photo

Если на вашем сайте «Няшные котики» есть каталог по породам,
то его вполне логично организовать в виде частей path,
поскольку каждый котик принадлежит ровно к одной породе.

А вот доставлять одного котика можно в несколько городов,
поэтому фильтр «с доставкой в город N» следует организовать через query.

3. Обращение по HTTP состоит из применения метода (глагола) к URL.
Результатом такого применения должно быть — сюрприз-сюрприз! — то, что в глаголе написано.
То есть GET возвращает представление ресурса, DELETE удаляет и т.п.

4. Методы GET, HEAD, OPTIONS — безопасные. Предполагается, что вызов этих методов состояния ресурса не изменяет.
Поэтому многие сетевые агенты — такие, например, как префетчер ссылок в браузере или мессенджере —
считают себя вправе по таким ссылкам ходить без явного волеизъявления пользователя. ИЧСХ, никаких стандартов не нарушают.

5. По умолчанию методы GET и HEAD кэшируются, OPTIONS, POST, PUT, PATCH, DELETE — нет.
Поэтому если вы шарахнули по Луне методом POST, вы можете быть (почти) уверены, что этот запрос выполнится.
Если вы шарахаете методом GET, какой-нибудь промежуточный прокси может ВНЕЗАПНО отдать вам ответ из кэша, и шарах в реальности не произойдёт.

