# MVC

isEngine построен с использованием концепции MVC (Модель-Вид-Контроллер). Данный подход позволяет разделить систему на три отдельных компонента.

Согласно концепции MVC, эти три компонента должны быть максимально изолированы друг от друга. Данный подход обеспечивает определенный уровень безопасности и облегчает разработку.

## Модель

Модель представляет собой то же самое, что модель в реальной жизни - модель поведения, модель ситуации. Из моделей, как из блоков, построена вся система.

Применимо к isEngine, базовые модели задаются фреймворком.

Работа с базой данных, работа с данными пользователей, вызов api - все это представлено различными моделями.

Эти базовые модели расширяются в ядре. И Вы также можете расширять их в вашем проекте.

## Контроллер

Контроллер выступает посредником между пользователем и системой. Как следует из названия, этот компонент отвечает за прием и обработку данных, поступивших от пользователя к системе.

Здесь важно понимать, что контроллер является самым тонким компонентом системы. Он лишь отвечает за контроль данных. Вся основная бизнес-логика построена на использовании моделей, вызове их методов и чтении состояний.

В isEngine контроллером выступает ядро. Оно взаимодействует с поступившими запросами и, в зависимости от ситуации, вызывает различные модели.

## Вид

Так же как контроллер принимает данные от пользователя, вид отдает пользователю определенные данные.

Под видом понимается интерфейс для работы с системой.

В isEngine в качестве вида выступают шаблоны. Однако в качестве вида может использоваться приложение, которое взаимодействует с системой через api.

## Модель вида

При работе с системой очень важно понимать отличие **модели вида** от самого **вида**.

Еще раз. **Вид** - это компонент в концепции MVC. В isEngine это шаблоны.

**Модель вида** - это часть фреймворка **isEngine**, одна из моделей.

Модель вида была создана в качестве прослойки между **видом** и всей остальной системой.

Согласно концепции MVC, вид не должен ничего знать ни о моделе, ни о контроллере. Однако, мы не можем полностью изолировать его от системы. Вид должен получать некоторые данные о системе, а в случае с административной частью, почти все эти данные. Если же мы дадим виду доступ к моделям, то получим тесную связь, в результате которой не сможем разделить эти два компонента.

> Если говорить в примерах, то любое изменение ядра или фреймворка повлечет необходимость менять шаблоны.

В данном случае, модель вида выступает единственным интерфейсом, с которым может работать вид. Через эту модель вид получает все необходимые данные.

Это решение также дает гарантию, что при дальнейшей разработке и развитии системы, вид сможет по-прежнему взаимодействовать с ней, независимо от своей или ее внутренней архитектуры.

> Возвращаясь к примерам, это означает, что шаблон будет корректно работать на разных версиях системы.
