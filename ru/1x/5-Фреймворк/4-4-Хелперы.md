# Хелперы

Хелперами принято называть вспомогательные функции. Эти функции используются самим фреймворком, ядром системы и компонентами. Вы также можете использовать их в своем коде.

В isEngine хелперы сделаны по нескольким причинам. Во-первых, чтобы облегчить код. Очень часто для совершения типовых операций приходится последовательно вызывать большое число функций языка. В это же число входят проверки на соответствие определенным типам данных. Все эти строки кода были помещены в хелперы. 

Вторая причина — типизация. Ряд встроенных функций языка, так сложилось, имеют различный принцип написания и разный порядок следования аргументов. Например:

    array_search()
    in_array()
    str_replace($needle, $replace, $haystack)
    strpos($haystack, $needle)

В уже существующем языке исправить подобные функции достаточно сложно. Поэтому мы заранее выбрали один формат и стараемся его придерживаться.

В третьих мы стараемся сделать фреймворк универсальным, чтобы его можно было портировать на различные платформы, в том числе на javascript. Однако в javascript попросту нет многих функций, привычных для php и наоборот. Либо одинаковые функции ведут себя по-разному. Поэтому в isEngine встречаются хелперы, являющиеся синонимами существующих функций языка или синтаксическим сахаром.

Сами хелперы представляют собой статические методы. Все хелперы инкапсулированы в статические классы по общему назначению. Это сделано для того, чтобы они не пересекались с существующими функциями языка. Также это предупреждает возможное совпадение с будущими функциями.

## Использование хелперов

Чтобы вызвать хелпер, достаточно объявить пространство имен его группы. Например:

    use is/Helpers/Strings;
    
    $result = Strings::replace($haystack, $needle, $replace);

Вызвать хэлпер таким способом можно из любой части кода.

## Встраивание хелперов

Также хэлперы можно использовать как методы класса. Для этого нужно объявить класс:

    use is\Helpers\Strings;
    
    $helper = new Strings;
    $result = $helper -> replace($haystack, $needle, $replace);

Зная это, можно включать хэлперы в свои классы:

    use is\Helpers\Strings;
    
    class MyClass {
      
      public $helper;
      
      public function __construct() {
        $this -> helper = new Strings;
      }
      
      ...
      
    }

## Наследование хелперов

Вы можете конструировать свои классы, которые будут наследовать хэлперы

    use is\Helpers\Strings;
    
    class MyClass extends Strings {
      
      ...
      
    }
