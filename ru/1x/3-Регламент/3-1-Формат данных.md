# Формат данных

В основе любой системы лежат данные, а сама система управляет доступом к ним. В расширенном виде это выглядит как чтение, запись и обмен (прием и передача), обработка и вывод данных на экран устройства пользователя.

Конечно, в любой системе существует множество правил, но самые главные - это правила работы с данными. isEngine задает свои правила и дает все необходимые инструменты для работы с ними.

## Обмен данными

### Запросы, клиент-сервер

В запросах можно передавать данные двумя способами:

- Через параметры запроса (query).

Например:

    https://site.com/path/to/page?one=1&two=2

- Через REST, как часть пути.

Например:

    https://site.com/path/to/page/rest/one/1/two/2/

В запросах можно использовать также спецсимволы, которые воспринимаются системой для фильтрации.

### Ответы, сервер-клиент

Для API в теле ответа используются два распространенных формата данных:

- plain text в формате JSON
- XML

## Хранение данных

Хранение данные реализуется через базу данных.

### Тип базы данных

В виде набора файлов в форматах:

- JSON,
- XML.

В виде таблиц в форматах:

- CSV,
- XLSX.

Через PDO:

- MySQL,
- Postgree,
- SQLite,
- Oracle,
- MongoDB.

### Структура разделов

Каждый раздел представляет из себя **коллекцию** (Collection), являющуюся набором **записей** (Entry).

Внутри коллекции записи могут быть структурированы двумя способами:

- в виде древовидной структуры (через **parents**),
- в виде тегированной структуры (через **type**).

Причем оба этих способа могут быть реализованы одновременно.

### Структура записей

**Запись** (Entry) включает:

- id - порядковый номер,
- name - имя записи,
- type - тип записи,
- parents - родители,
- ctime - время создания записи,
- mtime - время последнего изменения записи,
- dtime - время "конца жизни" записи,
- owner - владельцы,
- data - данные в формате json.

**Порядковый номер** служит для учета и проставляется автоматически. А вот **имя записи**, в отличие от номера, используется для идентификации записи. Это непохоже на большинство других систем, где идентификация записей идет по полю **id**.

Поле **тип записи** сделано специально для того, чтобы по нему можно было искать и фильтровать записи. Оно носит чисто служебный характер и не требует обязательного заполнения. Записывается в формате системных данных. Т.е. значение может быть преставлено строкой или массивом.

Поле **родители** похоже на **тип записи**, но служит для создания многоступенчатой иерархии записей. Это похоже на папки в файловой системе.

Поля времени служат для фильтрации и сортировки записей. Например, запись не может быть доступна для публикации, если ее **время создания** еще не подошло, или **время конца жизни** уже прошло.

Поле **владельцы** содержит идентификаторы пользователей, которые являются авторами записи или имеют на нее полные права собственности.

Поле **data** содержит произвольные данные в формате JSON.

Для ускорения обработки, данные могут быть представлены разными полями. В таком случае имя каждого поля должно начинаться с **data:**.

Пример записи данных в виде одного поля:

    data
    {"title": "Заголовок", "description": "Описание"}

Пример записи данных в виде разных полей:

    data:title | data:description
    Заголовок  | Описание

### Чтение

-

### Запись

-

## Передача данных между компонентами системы

### Оперативное хранилище

-

LoggerInterface, SessionInterface, ConnectionInterface - могут иметь различные реализации под разные хранилища, например можем захотеть хранить сессии в редисе

Например: озу сервера, сессия, куки

### Программная реализация хранения

-

Например: переменные, массивы, объекты

## Файловая система

### Формат файлов

Разрешенных форматов файлов всего два:

- **.ini** - для хранения настроек и прочих данных в формате **JSON**,
- **.php** - для файлов системы, включая классы и страницы шаблонов.

### Формат путей

Формат путей для папок **всегда** должен заканчиваться закрывающим слешем.

Формат путей для папок и файлов **никогда** не должен начинаться со слеша, **исключая** корневой путь.

> Также не забывайте использовать в **URL** слеш **/**, а в путях файловой системы - константу **DS**!

Пример для папок:

	folder/      # правильно
	folder       # неправильно
	/folder      # неправильно
	/folder/     # неправильно

Пример для файлов:

	folder.php   # правильно
	/folder.php  # неправильно
	/folder.php/ # неправильно
	folder.php/  # неправильно

Эти правила могут не соответствовать правилам файловой системы, но их соблюдение позволяет избежать ошибок при составлении пути.

Пример:

    $folder = 'folder/';
    $path = DR . $folder . 'file.php';
    echo $path;

Результат:

    ...directory_root/base/path/folder/file.php

Пример URL:

    $page = 'page.html';
    $folder = 'folder/';
    $path = 'https://site.com/' . $folder . $page . '?one=a';
    echo $path;

Результат:

    https://site.com/folder/page.html?one=a

**Внимение!** Пример ошибки:

    $page = '/page.html';
    $folder = '/folder/';
    $path = 'https://site.com/' . $folder . '/' . $page . '?one=a';
    echo $path;

Результат:

    https://site.com//folder///page.html?one=a

## Системные объекты

Данные в isEngine обрабатываются и передаются в виде ассоциативных массивов. Иногда данные могут быть представлены в виде простого массива, но даже в этом случае мы рассматриваем его как ассоциативный массив с числовыми индексами.

Эти данные мы называем **системными объектами**, а массивы - частная реализация их представления в языке PHP.

Для работы с **системными объектами** мы рекомендуем использовать хелперы группы **Objects**.

Помимо **системных объектов**, мы используем еще два формата хранения и передачи данных:

- JSON с некоторыми послаблениями,
- строка с разделителями.

Для преобразования этих данных мы рекомендуем использовать хелперы группы **Parser**.

### Формат JSON

Формат **JSON** используется в isEngine со следующими доработками:

- разрешены отступы строк в виде пробелов и табуляций
- разрешены переносы строк '\r', '\n' и '\r\n'
- разрешены комментарии вида '//' до конца строки
- разрешены комментарии вида '/*...*/'

### Строковый формат

В строке возможно разбиение данных на элементы через двоеточие **:** и на группы через прямую черту **|**.

Например, такая строка

    "group:item1:item2"

будет представлена в таком виде:

    {
      "group" : [ "item1", "item2" ]
    }

А такая строка

    "group1:item1:item2|group2:item3:item4"

будет представлена в таком виде:

    {
      "group1" : [ "item1", "item2" ],
      "group2" : [ "item3", "item4" ]
    }

### Упрощенный режим

При парсинге данных по-умолчанию включен **упрощенный режим**.

В этом режиме система старается воспринимать данные без учета групп.

Например, такая строка

    "group:item1:item2"

будет представлена уже в таком виде:

    [ "group", "item1", "item2" ]

А такая строка

    "group1:item1:item2|group2:item3:item4"

будет представлена в таком виде:

    [
      [ "group1", "item1", "item2" ],
      [ "group2", "item3", "item4" ]
    ]

### Флаг пропуска

Восклицательный знак в начале элемента воспринимается как флаг, отвечающий за пропуск данных.

Пример:

    "group:!item1:item2"

Результат:

    { "group" : [ "item2" ] }

Наличие восклицательного знака в ключе группы означает, что будет пропущена вся группа:

    "!group1:item1:item2|group2:item3:item4"

Результат:

    { "group2" : [ "item3", "item4" ] }

Также флаг пропуска работает в **системных объектах**:

    { "group1" : [ "!item1", "item2" ], "group2" : [ "!item3", "item4" ] }

Результат:

    [
      "group1" => [
        "item2"
      ],
      "group2" => [
        "item4"
      ]
    ]

Однако, настройки парсинга позволяют не учитывать этот флаг. Это оставлено, например, для управления настройками в панели администрирования.

### Текстовые переменные

isEngine позволяет использовать текстовые переменные. По-умолчанию, их вызов осуществляется через фигурные скобки:

    {name:attribute1:attribute2:...}

Однако Вы можете использовать любой другой определитель.

Текстовые переменные распознаются с помощью отдельного класса.

## Числа

Числа могут быть представлены в виде целых чисел **(int)**, чисел с плавающей точкой **(float)**, либо в виде строки **(string)**. Все эти три вида относятся к типу **numeric**.

В isEngine числа проверяются на соответствие типу **numeric**.

Ноль и единица также воспринимаются как числа.

> Будьте аккуратны с этим, так как в ряде случаев проверка на true/false сработает не так, как обычно!

При приведении к формату чисел средствами isEngine, запятая будет преобразована в точку, а все остальные символы, включая буквы, будут проигнорированы.

## Дата и время

Для запроса даты и времени используются те же обозначения, которые приняты в стандарте **ISO 8601**:

- YYYY - год, 4 знака: 2019
- MM - месяц, 2 знака, с нулем: 01-12
- DD - день, 2 знака, с нулем: 01-31
- hh - часы, 24-часовой формат, с нулем: 01-24
- mm - минуты, с нулем: 00-59
- ss - секунды, с нулем: 00-59

Однако мы расширили и дополнили их:

- YY - год, 2 знака: 19
- M - месяц, 1-2 знака, без нуля: 1-12
- D - день, 1-2 знака, без нуля: 1-31

- yy - год, 4 знака: 2019
- y - год, 2 знака: 19
- nn - месяц, 2 знака, с нулем: 01-12
- n - месяц, 1-2 знака, без нуля: 1-12
- dd - день, 2 знака, с нулем: 01-31
- d - день, 1-2 знака, без нуля: 1-31
- ww - день в году, 0-365
- w - день недели, 1-7

- h - часы, 24-часовой формат, без нуля: 1-24
- gg - часы, 12-часовой формат, с нулем: 01-12
- g - часы, 12-часовой формат, без нуля: 1-12
- m - минуты, с нулем: 00-59
- s - секунды, с нулем: 00-59

- p - префикс: am/pm
- z - временная зона, в миллисекундах: от -43200 до 50400

- aa - абсолютное время, число секунд и миллисекунд с эпохи UNIX
- a - абсолютное время, число секунд с эпохи UNIX

Мы рекомендуем использовать следующие названия:

- year - год, 4 знака: 2019
- month - месяц, 2 знака, с нулем: 01-12
- day - день, 2 знака, с нулем: 01-31
- hour - часы, 24-часовой формат, с нулем: 01-24
- min - минуты, с нулем: 00-59
- sec - секунды, с нулем: 00-59
- msec - миллисекунды, с нулем: 000-999
- ampm - префикс: am/pm
- week - номер недели в году, 1-42
- days - число дней в месяце: 28-31
- zone - временная зона, двоеточие между часами и минутами: +02:00
- abs - абсолютное время, число секунд с эпохи UNIX

Для вызова любого из перечисленных форматов, используются фигурные скобки, как в текстовых переменных.

Например:

    {day}.{month}.{year} {hour}:{min}

Результат:

    31.12.2019 23:59
