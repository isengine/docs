# Модули

Вызов модуля осуществляется через расширение 'module' класса 'View':

	$view -> get('module') -> launch(...);

Метод 'launch' принимает от 1 до 4 аргументов.

Первым следует название модуля. Например:

	$view -> get('module') -> launch('data');

Вторым - его настройки, шаблон и ассеты.

Задавать оба имеет смысл только если для одних и тех же настроек используется другой шаблон:

	$view -> get('module') -> launch('data', 'settings|template');
	$view -> get('module') -> launch('data', 'settings|template|assets');

Если имя настроек и шаблона совпадает, достаточно задать только одно:

	$view -> get('module') -> launch('data', 'instance');

Имя ассетов наследуется от шаблона и задавать его имеет смысл только в том случае, если у вас используются другие ассеты.

Для настроек, шаблонов и ассетов, можно указывать не только название, но и путь:

	$view -> get('module') -> launch('data', 'path:to:settings|path:to:template');

Если весь второй аргумент был пропущен, загрузятся настройки и шаблон по-умолчанию, т.е. 'default'.

Третьим аргументом можно принудительно изменить настройки.

Это может быть полезным, когда какая-то часть настроек меняется, в то время как все другие остаются прежними.

Настройки должны быть переданы в формате json.

Например:

	$view -> get('module') -> launch('data', 'instance', '{"first":"a","second":"b"}');

Последний, четвертый аргумент, принудительно задает кэширование модуля.

Вы можете разрешить или запретить общее кэширование для всех модулей в системе через конфигурационный файл. Но для определенного модуля вам может понадобится изменить эти настройки.

Значение 'true' принудительно разрешает кэширование. Значение 'null' принудительно выключает кэширование.

Например:

	$view -> get('module') -> launch('data', 'instance', '', true);
	$view -> get('module') -> launch('data', 'instance', '', null);

Шаблоны грузятся по приоритету:

* из пользовательской папки (по-умолчанию /app/Masters/Modules/.../templates/)
* из папки шаблона (по-умолчанию /vendors/.../templates/)

Настройки грузятся по приоритету:

* из базы данных (раздел 'modules')
* из пользовательской папки (по-умолчанию /app/Masters/Modules/.../data/)
* из папки модуля (по-умолчанию /vendors/.../data/)

Также модули поддерживают блоки, которые могут находится в папке 'blocks' на одном уровне с папкой шаблонов.

Также модули поддерживают некэшируемые блоки, которые могут находится в папке 'assets' на одном уровне с папкой шаблонов. Их вызов происходит после вызова шаблона модуля. И они всегда имеют то же имя, что и шаблон.

Сами модули загружаются в виде классов из пространства имен

	is\Masters\Modules\...

При этом они должны наследовать класс

	is\Masters\Modules\Master

При желании модули могут использовать несколько классов, расширять друг друга и даже вызывать один модуль из-под другого.

Базовые возможности модулей заданы во фреймворке.

В шаблонах и в блоках значение this соответствует классу модуля. В ассетах это значение соответствует мастер-классу. Однако в основном оно используется для чтения настроек, а настройки мастера и модуля идентичны, т.к. модуль принимает их из мастера.

Также по-умолчанию в модулях задано несколько методов автоматизации, благодаря которым вы только за счет настроек можете создавать определенные элементы.

Например, группа настроек 'elements' позволяет создать необходимые элементы dom-структуры еще до вызова шаблона модуля. А в самом шаблоне обращаться к ним через метод 'eget'. Например:

	$this -> eget('element-name') -> open;
	$this -> eget('element-name') -> close;

При этом, таким элементам назначаются классы.

Ассеты - это блоки, находящиеся в специальной папке. Они грузятся независимо от кэширования. Таким образом, если вы поместите туда код, вы сможете быть уверены, что он будет выполнен в любом случае.

Самое распространенное применение ассетов - скрипты и стили.

> Данный раздел находится в разработке
