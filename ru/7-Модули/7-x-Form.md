# Form

## Описание

Модуль вывода форм.

В основном, используется для обращения к api и передачи данных.

Например, авторизация и регистрация пользователей, вход в панель управления, обратная связь, создание заказа.

## Техническая информация

Класс

	Form

имеет четыре основных метода:

	buildFields()
	buildForm()
	printFields()
	printForm()

Методы build... строят форму, а методы print... выводят ее.

Вся форма строится через базовый метод мастера

	$this -> eget(...)

Который отвечает за управление DOM-элементами. И компонент

	Dom

который позволяет делать то же самое, но независимо.

Последний используется для построения встроенных тегов и перечислений. Например, options в select или нескольких checkbox.

Также для них существует поддержка текстовых переменных:

	{k} - ключ
	{i} - значение

Данный модуль является графическим интерфейсом для обращения к **api**.

По стандарту, используемому в системе, **api** как класс, относится к **мастерам**. Это означает, что он выступает в роли родителя и инициализирует внутри себя другие классы. Для **api** эти классы называются **методами**.

Нужные методы задаются в пространстве имен

	is\Masters\Methods

Сам класс **api** инициализируется системой при запросе соответствующего **url-адреса**. По-умолчанию, это

	/api/

Далее в адресе следует имя **метода как класса**, который будет объявлен в **api**. И затем - **метода как функции**, которая будет вызвана из-под этого класса.

Здесь сложность в понимании заключается только в терминологии.

Например, такой url:

	/api/user/authorize/

Вызовет класс **Api**:

	is\Masters\Api

Внутри него, в свойстве **method**:

	$this -> method

будет проинициализирован класс **User**:

	is\Masters\Methods\User

и вызван метод **authorize**:

	$this -> method -> authorize($data);

В качестве аргумента передаются данные из адресной строки.

В качестве настроек в класс **api** поступают данные, прочитанные из соответствующего раздела базы данных.

	/api/user/authorize/data/...

Также существует несколько опций, влияющих на поведение.

Можно весь сервер целиком сделать под разбор api. В таком случае, класс **api** будет инициализирован при любом url. И тогда

	/api/user/authorize/

превратится в

	/user/authorize/

Но тогда не будет смысла в использовании модуля формы.

Также через специальные поля можно передавать ключ и токен:

	/api/user/authorize/key/<your key>
	/api/user/authorize/token/<your token>

Токен нужен для определения времени запроса и защиты запроса от подделывания (XSS-атаки).

Ключ же служит для автоматической инициализации пользователя.

Без ключа, доступ к **api** проходил бы в два этапа:

	запрос на авторизацию
	запрос на действие

С ключом система позволяет сделать доступ в один этап:

	запрос на действие с авторизацией по ключу

Единственный момент, который нужно здесь учитывать, это то, что в случае когда пользователь уже авторизован, может произойти смена пользователя. Однако, если пользователь авторизован, ключ ему, возможно, не понадобится. По крайней мере, для данного модуля ключ точно не нужен.

В остальном, для реализации **методов api** нет никаких ограничений. Мы можем получать необходимые данные из url, из базы данных, загружать файлы и т.п.

Настройки полей также важно получать, чтобы проверить соответствие полученных значений требованиям формы.

## Настройки

**api**
Тип: **смешанный**
Возможные значения: **user:authorize**

Это поле определяет метод api, которому будут передаваться данные.

**method**
Тип: **смешанный**
Возможные значения: **get**, **post**, **files**

Это поле задает метод для формы.

Специальное значение **files** задает в качестве метода **post**, но при этом добавляет атрибут

	enctype="multipart/form-data"

**form**
Тип: **смешанный**

Раздел, который занимается управлением непосредственно контейнером формы. Это объект, в котором в качестве ключей передаются атрибуты.

Например:

	"form" : {
		"class" : "form-class",
		"id" : "form-id"
	}

Даст следующий результат:

	<form id ="form-id" class="form-class">
		...
	</form>

**data**
Тип: **смешанный**

Раздел настроек, который управляет содержимым формы.

Представляет из себя массив, содержащий объекты, описывающие каждое поле формы.

Пример:

	"data" : [
		{
			...
		},
		{
			...
		}
	]

## Раздел data

**name**
Тип: **смешанный**

Атрибут **name** поля.

**type**
Тип: **смешанный**
Возможные значения: **text**

Тип поля.

Обычно, для полей используется тег **input**, но в зависимости от типа, это может быть **textarea**, **button** и другие.

Специальные значения:

* checkbox - несколько полей input типа checkbox с несколькими вариантами выбора
* radio - несколько полей input типа radio с одним вариантом выбора
* list - поле input со списком вариантов для выбора
* select - поле select
* textarea - поле textarea

Остальные значения будут назначаться в качестве атрибута **type** тега **input**.

**required**
Тип: **смешанный**
Возможные значения: **true**, **false**, **null**

Обязательное поле или нет.

**multiple**
Тип: **смешанный**
Возможные значения: **true**, **false**, **null**

Разрешено ли выбирать несколько значений для поля или нет.

**class**
Тип: **смешанный**

Класс поля. Атрибут **class**.

**id**
Тип: **смешанный**

Атрибут **id** поля.

**options**
Тип: **смешанный**

Группа дополнительных настроек поля.

**data**
Тип: **смешанный**

Группа возможных для выбора значений.

Применяется к полям, для которых можно установить несколько значений на выбор. А именно для следующих **type**:

* checkbox
* radio
* list
* select

Представляет собой объект, в виде

	key : value

где **key** содержит значение поля, а **value** - выводимое пользователю значение.

Если ключи пропущены, то значения полей выставляются по индексам.

Пример:

	"name" : "options",
	"type" : "radio",
	"data" : [
		"option 1",
		"option 2",
		"option 3"
	]

Другой пример:

	"name" : "options",
	"type" : "radio",
	"data" : {
		"option 1" : "The title of 1st option",
		"option 2" : "The title of 2nd option",
		"option 3" : "The title of 3rd option"
	}

## Раздел options

**default**
Тип: **смешанный**

Значение по-умолчанию.

В зависимости от типа поля добавляется в атрибут **placeholder** или в другое нужное место.

**before**
Тип: **смешанный**

Блок перед полем.

Это значение будет целиком добавлено перед полем.

Например:

	<label class=\"btn btn-outline-primary\" for=\"btn-check-outlined-{k}\">Single toggle {i}</label><br>

**after**
Тип: **смешанный**

Блок после поля.

Это значение будет целиком добавлено после поля.

Например:

	<label class=\"btn btn-outline-primary\" for=\"btn-check-outlined-{k}\">Single toggle {i}</label><br>

**block**
Тип: **смешанный**

Блок для настраиваемого вывода поля.

По этому значению будет загружен блок из папки

	/blocks/

Обратите внимание, что переменная **items** будет представлена в виде массива из двух значений.

Первое - текущий DOM-элемент. Второе - массив настроек текущего элемента.

Таким образом, вы можете получить доступ к настройкам:

	$item[1]['options']

и к элементу:

	$item[0] -> print();

> Выводить элемент придется самостоятельно, через метод **print**, как показано выше.

Используя массив настроек, вы можете создавать свои записи и использовать их в блоках. Но нужно быть внимательным, чтобы ключи ваших записей не повторяли ключей, зарезервированных в модуле.

Например, добавить в опции ключ **description**:

	{
		...
		"options" : {
			...
			"description" : "..."
		}
	}

И вывести его в блоке:

	<?= $item[1]['options']['description']; ?>

**minlen**
Тип: **смешанный**
Возможные значения: **10**, **false**, **null**

> Опция была в прошлой версии системы. На данный момент не реализована. Может быть также совсем удалена.

**maxlen**
Тип: **смешанный**
Возможные значения: **10**, **false**, **null**

> Опция была в прошлой версии системы. На данный момент не реализована. Может быть также совсем удалена.

**clear**
Тип: **смешанный**
Возможные значения: **"phone phone_ru phone_link"**

> Опция была в прошлой версии системы. На данный момент не реализована. Может быть также совсем удалена.

**verify**
Тип: **смешанный**
Возможные значения: **"login notags numeric"**

тип проверки значения, используется, соответствует значениям функции datavalidation, кроме captcha - она проверяется отдельно через query и для него игнорируется значение required - оно все равно обязательное

> Опция была в прошлой версии системы. На данный момент не реализована. Может быть также совсем удалена.

**message**
Тип: **смешанный**
Возможные значения: **"Имя заказчика"**

если указано, отправлять в качестве заголовка данных (в сообщении администратору или менеджеру) это поле, иначе - text

> Опция была в прошлой версии системы. На данный момент не реализована. Может быть также совсем удалена.

**novalue**
Тип: **смешанный**
Возможные значения: **"Город не выбран"**

если указана эта опция, то при отправлении пустого значения (если, конечно, нет required),
в сообщении администратору (или менеджеру) будет указано то, что написано здесь
например, это может быть "не указано" или "клиент ничего не выбрал"

> Опция была в прошлой версии системы. На данный момент не реализована. Может быть также совсем удалена.

**nosend**
Тип: **смешанный**
Возможные значения: **true**, **false**, **null**

отправлять или нет это поле в сообщении

> Опция была в прошлой версии системы. На данный момент не реализована. Может быть также совсем удалена.

**filter**
Тип: **смешанный**
Возможные значения: **"href www"**

здесь задаются фильтры для вводимого в поле текста - это слова, разделенные пробелом, которые будут искаться в тексте
будьте внимательны, эти слова ищутся внутри - например "мес" будет найден в слове "вместе"
также поддерживаются некоторые регулярные выражения - но будьте внимательны!

> Опция была в прошлой версии системы. На данный момент не реализована. Может быть также совсем удалена.

## Из старой версии

!нет подключения разных полей для разных случаев - отдельно checkgroup select captcha и т.д.
!надо сделать вывод ошибок отдельным элементом с кастомизацией - взять свой с параметром модуля
!вернуть защиту от ботов, только сделать ее по кастомному полю с проверкой на пустое или значение не задано