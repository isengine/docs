Модуль вывода форм

В том числе используется для авторизации и регистрации пользователей (но не для входа в админку)

/*
если делать вызов через общий модуль форм, то не хватает:

1. определение типов - например, options -> target: user - будет грузить елемент user, в котором будут какие-нибудь особые условия, например для проверки кукисов и выхода
или нет... фигня... тогда проверку кукисов надо делать при вызове шаблона и если ок, то вызывать шаблон default, если нет - то шаблон exit
или шаблон регистрации - так будет лучше

2. отправлять или нет хэш?
*/

пока так:

{
	
	"type" : "registration", // это поле добавится в значение query формы, короче определяет, какой обработчик будет вызван
		// допустимые на данный момент значения:
		// authorisation - авторизация или выход из-под учетной записи
		// registration - регистрация на сайте
		// form - отправка почты с формы с доп. настройками
	"bootstrap" : false, // вкл/выкл бутстрапа
	"get" : true, // отправка по get или post
	"submit" : true, // разрешает выводить кнопку отправки, если строковое значение - то выводит название из поля lang -> action
	"errors" : true, // разрешает выводить информацию об ошибках
	"required" : true, // если нужно, чтобы все поля были обязательными для заполнения, можно указать эту опцию здесь, а не в каждом поле
	"log" : true, // вести лог событий
	"files" : false, // включить, если нужно вместе с формой отправлять файл, при этом отправка формы автоматом будет по post, даже если "get" : true
	"redirect" : true, // разрешить ли редирект со статусом, если да, то после обработки данных будет редирект на страницу _исходный_адрес_/?query=_имя_модуля_&status=_статус_
	"time" : num/string, // можно указать время жизни формы, тогда это время будет прибавлено ко времени по-умолчанию, значения: "hour" или цифровое
	
	"form" : [ // перечисляются поля формы
		{
			"name" : "login", // имя инпута - data[name]
			"type" : "text", // тип инпута - text/password/date/email что там еще... для textarea - textarea, для button - submit
			"verify" : "login", // тип проверки значения, используется, соответствует значениям функции datavalidation, кроме captcha - она проверяется отдельно через query и для него игнорируется значение required - оно все равно обязательное
			"label" : "", // а это поле нужно, чтобы задать лейбл - причем лейбл в отличии от дескрипшена ставится перед инпутом, но суть та же
			"required" : true // нужно, если это поле обязательно для заполнения
		},
		{
			"name" : "passwordconfirm",
			"type" : "password",
			"verify" : "password",
			"text" : "confirm password", // если задано, то будет подставлено в плейсхолдер, а для кнопки - в значение кнопки
			"description" : "confirm your password here" // если задано, то будет создан доп.контейнер span после инпута с этим текстом (а лучше языковой ссылкой в поле names, так что задавайте сами и лучше вида form_label_...)
		},
		{
			"name" : "food",
			"type" : "checkgroup", // для выставления группы флажков, select - для select'а
			"options" : {
			// options или флажки, где ключ - значение, а val - отображаемое имя
			// можно указать вместо массива значение в кавычках, тогда массив будет сгенерирован автоматом, например:
			// "structure:group" - сгенерирует из раздела структуры group
			// "structure:group:subgroup" - если указать третий параметр, то будет искать в разделе group вложенный раздел subgroup и генерировать из него
			// к сожалению, данный функционал не реализован в виде рекурсии параметров, что было бы логичнее
			// "articles:group:id" - сгенерирует из группы материалов group со значением из поля id
			// "articles:group:id:title" - сгенерирует из группы материалов group с текстом из поля title
			// "articles:group:id:title:include" - если указать четвертый параметр, то будет добавлять только те материалы, в которых есть это поле и оно не пустое и не false
				"1" : "Обед",
				"2" : "Ужин",
				"3" : "Кофе-брейк",
				"4" : "Банкет"
			},
			"options_title" : "" // если указана эта опция, то в начало списка будет добавлен пустой пункт в качестве заголовка
			"novalue" : ""
			// если указана эта опция, то при отправлении пустого значения (если, конечно, нет required),
			// в сообщении администратору (или менеджеру) будет указано то, что написано здесь
			// например, это может быть "не указано" или "клиент ничего не выбрал"
			"verify" : "numeric", // здесь верификация для каждого чека или для селекта целиком
			"filter" : "...", // здесь задаются фильтры для вводимого в поле текста - это слова, разделенные пробелом, которые будут искаться в тексте
			// будьте внимательны, эти слова ищутся внутри - например "мес" будет найден в слове "вместе"
			// также поддерживаются некоторые регулярные выражения - но будьте внимательны!
			"text" : "Питание",
			"class" : "", // дополнительные классы
			"placeholder" : "" // плейсхолдер, например если текст ставится в тег label
			"nosend" : "" // true/false - не отправлять это поле в сообщении
			"message" : "" // если указано, отправлять в качестве заголовка данных (в сообщении администратору или менеджеру) это поле, иначе - text
			для select'а доступны также multiple и size
			!нет radio
			!нет кастомизации классов в дефолте
			!нет подключения разных полей для разных случаев - отдельно checkgroup select captcha и т.д.
			!надо сделать вывод ошибок отдельным элементом с кастомизацией - взять свой с параметром модуля
		},
	]
	
	"send" : { // этот раздел - для отправки уведомлений, например администратору сайта о поступившем заказе и т.п.
		"type" : "email", // тип канала - email, vkontakte, sms, whatsapp (через сервисы-шлюзы)
		"param" : "",
		"id" : "admin@site.com, mail@site.com", // перечисление идентификаторов пользователей
		"key" : "" // это поле для api-key, если вы используете шлюзы,
		
		"template" : ""
		// true/false, пока только для всех видов email,
		// работает так: перед вызовом функции message в query модуля form проверяется наличие этого поля и его true и тогда в него записывается param модуля
		// затем в функции messageSend также проверяется наличие этого поля и на основе строится путь к шаблону (в папке module/form/templates/param_type.php)
		// далее внутри подготовки сообщения для типа email и аналогичных вызывается этот шаблон, если он есть, через require
		// там никаких проверок уже нет, соответственно, шаблон должен строится на тегах и вызовах
		// используемые переменные: $site, $subject, $message и foreach ($data as $item) : $item['label'] . $item['value']
		// шаблон формируется в переменной $text, которая в самом начале объявляется пустой, а в конечном итоге записывается в переменную $message
	}

}

Если назначен тип "form", это говорит препроцессору обращаться к обработчику модуля. Обработчик модуля по-умолчанию настроен на отправку сообщений на указанный e-mail адрес и уведомление администратора через e-mail, vkontakte, whatsapp и смс-сервисы.

Отправка сообщений идет через стандартную функцию message, которая принимает данные и настройки и отправляет их функции messageSend, которая, собственно, и занимается отправкой сообщений.

Чтобы предупредить авто-боты, стоит простая система защиты, которая проверяет в полученных данных наличие пустого значения 'check'. Дело в том, что роботы стараются заполнить все поля, а данное поле по-умолчанию должно быть скрыто от пользователя, но не через тип "hidden", а через стиль "display:none". В шаблоне по-умолчанию, если вы выбрали тип "form", данное поле будет добавлено автоматически. Если же вы используете свой шаблон, вам придется прописывать его самостоятельно:

	<input type="text" name="check" value="" style="display:none!important;">

Еще одно поле, без которых данные формы не будут действительными, это поле "hash". В своем шаблоне, причем это не зависит от типа формы, вы должны прописать:

	<input type="hidden" name="hash" value="<?= datacrypt(time()); ?>">

Будьте внимательными к наличию этих двух полей!

========================
Обработка и вывод ошибок
========================

В модуле есть возможность выводить ошибки при указании параметра "errors" : true.

При разработке шаблонов и доработке этого модуля будьте внимательны! Шаблон по-умолчанию принимает код ошибки из объекта $query -> errors и переводит в массив $module -> data['errors'].

Код ошибки считывается из ключа, и по этому ключу ведется поиск ошибки в объекте $lang -> errors, где перечислены самые распространенные системные ошибки. Если же ключ в данном объекте не найден, то выводится значение данного ключа. Здесь массив также предварительно подвергается чистке по языкам, так что можно управлять языками при выводе ошибок.

Вот так будет выведена ошибка 'email' => true:

	"Incorrect email"

А вот так будет выведена ошибка '0' => 'email':

	"email"

А вот так будет выведена ошибка '0' => { 'en' : 'email', 'ru' : 'эл.почта' }:

	для русского языка: "эл.почта",
	для английского языка: "email"

Шаблон вывода ошибок подключаются через require 'elements' . DIRECTORY_SEPARATOR . 'hidden';

Теперь модуль отбрасывает проверку для тех полей, которые были необязательны к заполнению и у которых пустое значение.
Но если значение не пустое, они все равно проверяются.

============
Вывод ошибок
============

Всего на данный момент поддерживаются следующие статусы:

ready - форма подготовлена к отправке, но она еще должна пройти валидацию
fail - форма не прошла валидацию
complete - форма успешно отправлена

На самом деле, если отправить статусы ready или complete вместе с данными формы, форма все равно не будет отправлена,
т.к. эти статусы назначаются при проверке.

Однако, их можно использовать в выводе формы. Например:

	if (
		!empty($module -> data['errors']) &&
		$module -> status !== 'ready'
	) {
		echo 'сообщение об ошибке';
	} else {
		echo 'нет сообщения об ошибке';
	}

===============
Ссылка на форму
===============

Если вы хотите сделать ссылку на форму с предварительно заполненными полями, то вам нужно:

1. указать в структуре для страницы с формой параметр 'params', который разрешит принимать значения по get/post
 
! Кстати, это лучше сделать в любом случае для всех форм

2. разместить ссылку вида

	/.../?field=value
	или ...?field=value

! Кстати, для списков, сгенерированных из материалов, value строится по следующему принципу:

	название третьего параметра + нижнее подчеркивание + его значение
	т.е. если у вас в параметрах было написано "articles:group:id:title", а нужный id материала будет, скажем, 2, то ссылка должна быть такой:
	?field=id_2

======================================
Кастомизация и обработка формы вручную
======================================

Конечно, на данный момент модуль не может предоставить большие возможности для настройки шаблона. Поэтому, если вам нужна сложная форма, имеет смысл просто ссылаться на данную форму, а сам шаблон целиком кастомизировать.

Самое главное - это соблюдать стандарт.

1. должны быть указаны поля
	
	<input type="hidden" name="query" value="form">
	<input type="hidden" name="param" value="_параметр-модуля_">
	<input type="text" name="check" value="" style="display:none!important;">
	<input type="hidden" name="hash" value="<?= datacrypt(time()); ?>">

Эти поля подключаются через require 'elements' . DIRECTORY_SEPARATOR . 'hidden';
Также нужные условия формы можно подключить через require 'elements' . DIRECTORY_SEPARATOR . 'attributes' прямо внутри тега '<form>';

2. все данные должны передаваться через

	name="data[_название_]"

3. в данных модуля должен быть файл _параметр-модуля_.ini со всеми данными, как если бы форма вызывалась в автоматическом режиме, в том числе с указанием валидации и обязательных требований, т.к. эти настройки понадобятся при обработке

4. если вы хотите обрабатывать возвращаемые данные формы - в атрибут value или placeholder вставьте код
	
	<?= (!empty($query -> data['_название_'])) ? $query -> data['_название_'] : ''; ?>

5. если вы хотите обрабатывать результат формы
	
	включите настройку "redirect" : true
	в место вывода вставьте проверку
		
		if (!empty($query -> status)) {
			if ($query -> status === 'complete') {
				...
			} else {
				...
			}
		}

6. если вы хотите вывести сообщение для успешно отправленной формы, используйте

	"message" : {
		"complete" : "Ваше сообщение отправлено успешно!",
		"refresh" : "Отправить другое"
	}

Они выведут текст (поддерживаются все разрешенные теги или кастомизируйте в шаблоне сами)
и сообщение для кнопки отправки

Поля по-умолчанию подключаются через require 'elements' . DIRECTORY_SEPARATOR . 'complete';

=============================
Кастомизация полей по шаблону
=============================

Если ваша форма имеет необычный шаблон, но поля при этом имеют абсолютно одинаковое содержание,
их можно задать через шаблон 'template_field.php', где 'template' - имя вызываемого вами шаблона.

Данные в шаблоне поля вызываются через объект $item. Например:
$item -> name, $item -> type, $item -> required и так далее

В месте вызова поля достаточно использовать функцию
moduleFormGenerate(num, $module);
где num - порядковый номер поля в настройках модуля,
а $module - собственно, объект модуля, его менять не нужно

Пример такой кастомизации

Файл 'template.php':

	<div class="form_cell">
		<?php moduleFormGenerate(0, $module); ?>
	</div>
	<div class="form_cell">
		<?php moduleFormGenerate(1, $module); ?>
	</div>
	<div class="row">
		<div class="form_cell w50">
			<?php moduleFormGenerate(2, $module); ?>
		</div>
		<div class="form_cell w50">
			<?php moduleFormGenerate(3, $module); ?>
		</div>
		<label class="agreement_checkbox">
			<?php $item = $module -> settings -> form; ?>
			<input class="js_agreement_checkbox" type="<?= $item[4] -> type; ?>" value="1" name="data[<?= $item[4] -> name; ?>]" checked="">
			<span class="personal-date-sitebar">Я даю согласие на обработку моих <a target="_blank" href="/useragreement/">персональных данных</a>.</span>
		</label>
	</div>

Файл 'template_field.php':

	<input
		type="<?= $item -> type; ?>"
		id="feedback-<?= $item -> name; ?>"
		class="input_text"
		name="data[<?= $item -> name; ?>]"
		placeholder="<?= $item -> text; ?><?= (!empty($item -> required)) ? ' *" required aria-required="true' : ''; ?>"
		<?= (!empty(dataobject($module -> data, $item -> name))) ? ' value="' . dataobject($module -> data, $item -> name) . '"' : '';?>
	>
	<div class="help-block"><?php
		unset($module -> data['errors']['fail']);
		if (
			!empty($item -> name) &&
			!empty($module -> data['errors']) &&
			is_array($module -> data['errors']) &&
			in_array($item -> name, $module -> data['errors'])
		) {
			global $lang;
			if (dataobject($lang -> errors, $item -> name)) {
				echo dataobject($lang -> errors, $item -> name);
			} else {
				echo 'Введенный текст слишком короткий или содержит недопустимые символы';
			}
		}
	?></div>

=======
Шаблоны
=======

Шаблон задается в параметре "template" : true/false, пока только для всех видов email

Работает так: перед вызовом функции message в query модуля form проверяется наличие этого поля и его true и тогда в него записывается param модуля

Затем в функции messageSend также проверяется наличие этого поля и на основе строится путь к шаблону (в папке module/form/templates/param_type.php)

Далее внутри подготовки сообщения для типа email и аналогичных вызывается этот шаблон, если он есть, через require

Там никаких проверок уже нет, соответственно, шаблон должен строится на тегах и вызовах

Используемые переменные: $site, $subject, $message и foreach ($data as $item) : $item['label'] . $item['value']

Шаблон формируется в переменной $text, которая в самом начале объявляется пустой, а в конечном итоге записывается в переменную $message

==============================
Настройка отправки уведомлений
==============================
	
	"message" : {
		"place" : "столик",
		"date" : "дата",
		"time" : "время",
		"user" : "имя",
		"email" : "email",
		"phone" : "телефон",
		"lang" : "язык",
		"currdate" : "заказ создан",
		"addition" : "комментарии",
		"status" : "статус",
		"subject" : "Новый Заказ",
		"text" : "С сайта поступил новый заказ! Данные заказа:",
		
		"complete" : "Ваше сообщение отправлено успешно!",
		"refresh" : "Отправить другое"
	},
	"send" : [
		{
			"type" : "",
					// email, vk, whatsapp, sms, в разработке telegram, viber, skype
			"param" : "",
					// параметр отправки
					// для email это адрес smtp сервера или phpmail
					// для vk это "user_id", "chat_id" или "domain"
					// для смс это адрес шлюза со вставками ключей в фигурных скобках {}
					// для whatsapp это также адрес шлюза
			"id" : "",
					// идентификатор, может быть один или несколько в массиве, например ["..","..",".."]
					// для email это список адресов рассылки
					// для vk это значения user_id, chat_id или domain
					// для смс это номера телефонов для отправки
					// для whatsapp это также номера телефонов
			"key" : ""
					// ключ
					// для email это связка логин:пароль
					// для vk это access_token приложения
					// для смс это массив со значениями ключей, которые будут подставляться в адрес шлюза
					// для whatsapp это token
		}
	]

примеры:
	
	"send" : [
		{
			"type" : "vk",
			"param" : "domain",
			"id" : ["user1", "user2"],
			"key" : "01234567890abcdefghijklmnopqrstuvwxyz01234567890abcdefghijklmnopqrstuvwxyz01234567890"
		},
		{
			"type" : "email",
			"param" : "",
			"id" : ["my@mail.ru", "my@yandex.ru"],
			"key" : ""
		},
		{
			"type" : "sms",
			"param" : "https://{login}:{key}@gate.smsaero.ru/v2/sms/send?number={id}&text={message}&sign={sign}&channel=DIRECT",
			"id" : "79xxxxxxxxx",
			"key" : {
				"login" : "mail@mail.ru",
				"key" : "aAbBcCdDeEfFgGhHiIjJkKlLmMn",
				"sign" : "BIZNES"
			}
		},
		{
			"type" : "whatsapp",
			"param" : "https://web.chat-api.com/instance00000/",
			"id" : "79xxxxxxxxx",
			"key" : {
				"key" : "abcdefghijklmnop",
				"token" : "token",
				"id" : "phone",
				"message" : "body"
			}
		},
		{
			"type" : "whatsappget",
			"param" : "https://panel.apiwha.com/send_message.php",
			"id" : "79xxxxxxxxx",
			"key" : {
				"key" : "TRIAL0123456789ABCDE",
				"token" : "apikey",
				"id" : "number",
				"message" : "text"
			}
		}
	]
