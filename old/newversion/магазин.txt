Магазин выполнен как модуль, но на самом деле это группа модулей, объединенных в один.

Как водится, группа разделена разными установками и шаблонами.

Сам же модуль при инициализации проверяет, с какими настройками он вызван и подгружает соответствующий процесс.



Общий принцип работы

1. зависимость от других модулей и компонентов системы

Модуль спроектирован в тесном взаимодействии с контентом, на базе которого построен каталог, и формами.

Важно обратить внимание на то, что товары, даже отсутствующие в наличии, должны оставаться в базе контента, иначе информация по ним не сможет быть подтянута в заказ.

Если же вы не хотите выводить какие-то товары из каталога, можно предусмотреть в них поле, например, архив, и исключать контент по этому полю при выводе.

2. база данных

Этот модуль также имеет свою базу данных.

Можно было бы построить базу данных на основе полей пользователя. Однако, в таком случае, во-первых никто, кроме пользователя, не сможет получить информацию о заказах, а во-вторых, если хранить все заказы, то информация о пользователе станет слишком большой. Что касается первого пункта, заказы должны читать и отслеживать менеджеры и логистика. Если хранить их у пользователя, они могут получить доступ к другим его данным, что недопустимо с точки зрения безопасности. А насчет второго пункта, информация пользователя хранится в куках и в сессии, она превысит лимит кук и случится коллапс. Чтобы этого не произошло, куки придется чистить, а это дополнительная логика, трата ресурсов и времени, причем бесполезная.

В базе данных должна содержаться следующая информация:

	- номер / название / идентификатор заказа
	- дата составления заказа
	- текущее состояние
	- прочие промежуточные даты для отчетности - оприходование/проверка, оплата/предоплата (если есть), составление/сбор, отправление/передача в пункт/логистика, доставка/прибытие в пункт выдачи, получение (возможно, с оплатой), завершение
	- лог или информация о возникших ошибках, например, не прошла оплата, неверно указан адрес, не было доставлено, не было получено и т.д.
	- номер / название / идентификатор пользователя
	- данные о получателе - фио, email, контактный телефон, адрес доставки, вид оплаты, вид доставки, данные по карте (зашифрованные, если поддерживается сервисом оплаты)
	- данные об оплате
	- состав заказа - номер / название / идентификаторы товаров из каталога

3. защита информации

Отдельно нужно поговорить по поводу защиты информации о заказе от подделывания, в том числе информации о ценах в составе заказ и об оплате.

Значит, при формировании заказа в обработчик поступают только идентификаторы товара. Никакая другая информация, в том числе цена, не передается. Все необходимые данные о товарах в составе заказа собираются обработчиком заново. Таким образом, цена не передается через формы и таким способом ее невозможно подделать.

4. формирование цен, акции

При формировании цены идет учет следующих показателей:

	- общий массив заказа - a (array)
	- идентификатор товара - name
	- цена товара старая (обычная) - p (price)
	- цена товара новая (акционная) - pa (price action)
	- размер скидки по акции - sa (sale action)
	- размер скидки пользователя - su (sale user)
	- суммарная цена - pt (price total)
	- суммарная скидка - st (sale total)

Расчет зависит от следующих настроек:

	- скидки суммируются (opt = true) или не суммируются (opt = false)
	- минимально допустимая цена товара - pm (price min)
	- минимально допустимый размер скидки - sm (sale min)
	- скидка разрешена для всех пользователей или только для определенных групп (задаются по полю данных пользователя в формате "поле:значение")

Расчет идет по такой схеме:

	- если указана новая цена товара, то старая цена товара не учитывается,
	при этом предварительно высчитывается коэффициент скидки (sp - sale from price)
	он не будет задействован при расчете итоговой суммы, а нужен лишь для формул сравнения скидок
	if (!empty($pa)) { $sp = 100 - pa * 100 / p; $pt = $pa; } else { $sp = 0; $pt = $p; }
	
	- если указаны новая цена товара и размер скидки по акции, то вычисляется, что больше и этот параметр не учитывается,
	другими словами, работает только самая низкая цена, т.е. самая большая скидка
	if (!empty($sp) && !empty($sa)) { if ($sa < $sp) { $sa = 0; } else { $pa = 0; } }
	
	- если скидки не суммируются, то вычисляется самая большая скидка, и работает только она
	здесь то же самое - работает только самая низкая цена, т.е. самая большая скидка
	если же скидки суммируются, то вычисляется сумма всех скидок
	if (empty($opt)) { $st = ($sa > $su) ? $sa : $su; } else { $st = $sa + $su; }
	
	- если задан минимально допустимый размер скидки, то он сравнивается с итоговой скидкой и в случае необходимости срабатывает ограничение
	if (!empty($sm) && $st < $sm) { $st = $sm; }
	
	- высчитывается итоговая сумма товара
	$pt = round($pt * (1 - $st / 100), 2);
	
	- высчитывается итоговый показатель скидки
	$st = round(100 - $pt * 100 / $p);
	
	- если задана минимально допустимая цена товара, то она сравнивается с итоговой суммой и в случае необходимости срабатывает ограничение
	if (!empty($pm) && $pt < $pm) { $pt = $pm; }
	
	- итоговые данные записываются в массив, который затем записывается в общий массив, таким образом формируя массив заказа
	$a[$name] = ['p' => $p, 'pt' => $pt, 'st' => $st];

После того, как расчитана сумма каждого товара, расчитывается сумма заказа.

Итоги хранятся в массиве 't' (total):

	- общая сумма заказа к оплате - c (cost)
	- cумма заказа без скидок (обычная) - p (price)
	- сумма заказа со скидками - pt (price total)
	- суммарная скидка за весь заказ - st (sale total)
	- стоимость доставки - d (delivery)

В массиве 'sets' хранятся настройки для заказа:

	'every'
	группа настроек, задающих условия для каждого определенного товара в корзине
		
		'each'
		скидка на каждый n-ный товар в корзине, начиная с самого дешевого
		
		'sale'
		размер скидки в процентах
		
		'price'
		размер фиксированной стоимости, если она не превышает реальную
		
	'delivery'
	группа настроек, задающих условия для расчета доставки
		
		'price'
		фиксированная сумма заказа, если вам так угодно
		
		'percent'
		процент от суммы заказа, если вам так нужно
		
		'line'
		пороговое значение, после которой будет начисляться процент
		
		'freeship'
		минимальная сумма заказа, начиная от которой доставка будет бесплатной
	
	'gift'
	группа настроек, задающих условия для выбора подарков
		
		'price'
		фиксированная сумма подарков, которую нельзя превышать
		
		'count'
		фиксированное число подарков
		
		'group'
		группа подарков в формате 'field:value',
		где 'field' - поле данных из каталога, а 'value' - допустимое значение этого поля
		т.к. фильтрация будет происходить через драйвер базы данных, то подробное использование смотрите там
	
	'process'
	группа настроек, задающих условия для общего процесса формирования заказа
		
		'balance'
		разрешено ли задействовать баланс в личном кабинете
		
		'payment'
		разрешена ли оплата на сайте
		
		'confirm'
		нужно ли подтверждать заказ через e-mail, чтобы запустить его в работу

Расчет идет по такой схеме:

	- во-первых, товары сортируются по итоговой цене по возрастанию
	array_multisort(array_column($a, 'pt'), SORT_ASC, SORT_NATURAL, $a);

	- во-вторых, если включена опция "каждый n-ный товар по доп.скидке, либо по фикс.цене",
	с учетом того, что товары ранее были отсортированы по цене, идет расчет количества товара и изменение данных первых n товаров
	
	if (objectIs($a) && !empty($sets['every']['each'])) {
		$n = floor(count($a) / (int) $sets['every']['each']);
		if (!empty($n)) {
			for ($i = 0; $i < $n; $i++) {
				$name = key($a);
				$ii = array_shift($a);
				if (!empty($sets['every']['sale']) && is_numeric($sets['every']['sale'])) {
					if ($sets['every']['sale'] > $ii['st']) {
						$ii['pt'] = round($ii['p'] * (1 - (int) $sets['every']['sale'] / 100), 2);
						$ii['st'] = $sets['every']['sale'];
					}
				} elseif (set($sets['every']['price']) && is_numeric($sets['every']['price'])) {
					if ($sets['every']['price'] < $ii['pt']) {
						$ii['pt'] = $sets['every']['price'];
						$ii['st'] = round(100 - $ii['pt'] * 100 / $ii['p']);
					}
				}
				$a[$name] = $ii;
			}
			unset($i, $ii, $name);
		}
	}

	- в-третьих, расчитываются итоговые показатели на весь заказ
	$t = ['p' => array_sum(array_column($a, 'p')), 'pt' => array_sum(array_column($a, 'pt')), 'st' => null, 'd' => null, 'c' => null];
	$t['st'] = round(100 - $t['pt'] * 100 / $t['p']);

Расчет и сохранение заказа в базу данных происходит при нажатии на кнопку "оформить". Если пользователь не был авторизован, ему необходимо войти в систему. До этого заказ не сохраняется в базу, а хранится в виде корзины покупок в куках. После оформления заказа он записывается в базу данных со статусом оформлен. Однако он пока еще не подтвержден.

Пока заказ не подтвержден, его еще можно изменить. Виды изменений, на самом деле, зависят от настроек:

	- использование одноразового/многоразового/личного промокода на скидку, либо на определенную сумму
	- бесплатная доставка для определенной группы пользователей, либо на заказ от определенной суммы
	- добавление на выбор в качестве подарка ограниченного числа или любого числа на определенную сумму любых товаров или товаров из определенной группы

Промокоды

Промокод применяется к сумме всего заказа.

Промокоды хранятся в отдельной таблице.

Имя записи соответствует имени промокода. При его активации читаются настройки.

Код может быть одноразовым вообще, одноразовым для каждого пользователя, либо многоразовым. Также код может быть открытым для всех или персональным. Также промокод может быть ограничен по времени, по сумме заказа или по максимальной скидке на весь заказ. Если код одиночный для каждого пользователя, то читается массив данных, содержащий идентификаторы пользователей и по этому массиву проверяется, был ли активирован код для этого пользователя или нет. Здесь важно проверить, чтобы идентификатор пользователя был уникальным и не менялся каждый раз при авторизации. По-идее, это имя пользователя и оно не должно быть пустым, т.к. если имя пустое, значит пользователь не авторизован.

Промокод может предоставлять скидку в процентах или в виде купона на сумму.

После подтверждения заказа промокод, если это был одиночный промокод, сгорает, т.е. в базе данных изменяются данные по нему.

Доставка

Оплату за доставку можно включать в заказ, либо не включать - все зависит от вашей логистики. Сумма доставки может считаться в отдельном подключаемом коде. Этот код также может запрашивать сумму доставки, используя api ваших поставщиков. Самый простой вариант - устанавливать сумму доставки вручную к заказу после его обработки.

Однако, несмотря на всяческие расчеты, вы можете задать настройки доставки, благодаря которым доставка будет считаться автоматически от суммы заказа.

	if (objectIs($a) && objectIs($sets['delivery'])) {
		if (!empty($sets['delivery']['freeship']) && $t['pt'] >= (int) $sets['delivery']['freeship']) {
			$t['d'] = 0;
		} else {
			$t['d'] = !empty($sets['delivery']['price']) ? (int) $sets['delivery']['price'] : 0;
			if (
				!empty($sets['delivery']['percent']) &&
				(
					empty($sets['delivery']['line']) ||
					!empty($sets['delivery']['line']) && $t['pt'] > (int) $sets['delivery']['line']
				)
			) {
				$t['d'] += round($t['pt'] * (int) $sets['delivery']['percent'] / 100);
			}
		}
	}
	
Подарки

При достижении определенных условий (как правило, какой-то минимальной суммы заказа), вам будут предложены подарки.

Подарками могут быть товары из каталога (возможно также из спец.каталога), которые могут быть ограничены:

	- определенным полем и его значением
	- суммой
	- числом

Эти товары предлагаются на выбор через вызов отдельного компонента данного модуля и сохраняются отдельной позицией в данном заказе в базе данных.

Работа с подарками может быть организована по ajax, а может через промежуточный шаблон формирования заказа.

Завершение оформления

После всех этих расчетов пользователю выводится общая информация о заказе. Если он хочет что-либо изменить, например, добавить или удалить товар, выбрать подарок или ввести промо-код, каждый раз при совершении таких изменений, все расчеты производятся заново. Это сделано для того, чтобы пользователь не смог подменить какие-либо данные.

Итоговая сумма к оплате расчитывается по следующей формуле:

	- общая стоимость заказа суммируется со стоимостью доставки
	$t['с'] = $t['pt'] + $t['d'];

После того, как заказ будет одобрен пользователем, ему нужно нажать кнопку "Завершить оформление".

Если в настройках задан процесс подтверждения заказа по email, то заказ запишется в базу данных со статусом 'не подтвержден' и оплата будет доступна только после подтверждения. Если же эта настройка пропущена, то заказ сразу запишется со статусом 'подтвержден' и можно будет перейти к оплате.

Оплата

Процесс оплаты доступен только если он включен в настройках. За сам процесс отвечают файлы расширений. Так, вы сами сможете организовать оплату через любой нужный вам сервис.

После оплаты статус заказа меняется на 'оплачен' и теперь он ждет действий со стороны компании.

Отмена и изменение заказа

Подтвержденный заказ невозможно изменить - только оплатить или отменить.

На самом деле, отменить заказ можно в любое время. Но если он был оплачен, то обработка потребует ручного вмешательства, т.к. нужно будет вернуть позиции на баланс, а для возврата средств, особенно по карте, нужно будет создавать запрос в банк.

Однако, если в настройках задействован баланс, то средства будут просто зачислены на баланс пользователя. Но баланс как таковой требует большего контроля со стороны системы. К тому же его нужно будет хранить в данных пользователя.

Если отменить заказ уже переданный в службу доставки, то вполне возможно, что сумма доставки будет удержана и пользователю вернется только стоимость самого заказа.

Доставленный заказ отменить уже никак не получится. Здесь можно инициировать процедуру возврата.







