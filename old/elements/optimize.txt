Ну, во-первых, использовать empty($...) вместо !isset($...) || !$...

(empty($a)) ::: (!isset($a) || !$a) ( !isset ($a) || ! $a)
(!empty($a)) :: (isset($a) && $a)

для поиска (!isset(...) || !...) регулярка \(\s?!\s?isset\s?\((.+?)\)\s?\|{2}\s?!\s?(.+?)\s?\) замена (empty($1))
для поиска !isset(...) || !... регулярка !\s?isset\s?\((.+?)\)\s?\|{2}\s?! замена empty(

для поиска (isset(...) && ...) регулярка \(\s?isset\s?\((.+?)\)\s?\&{2}\s?\s?(.+?)\s?\) замена (!empty($1))
для поиска isset(...) && ... регулярка isset\s?\((.+?)\)\s?\&{2}\s? замена !empty(

Результат оптимизации:
before php memory: 1.598 Mb / php max memory: 2.053 Mb
after  php memory: 1.588 Mb / php max memory: 2.039 Mb

Может, еще добавить условия проверок через функцию?

Например, стандартные операции проверки:
	isset($i) && $i > !empty($i)
	!isset($i) || !$i > empty($i)
	isset($i) && count($i)
	isset($i) && is_numeric($i)

===

Во-вторых, в echo и прочих стараться заменить оператор присваивания точку (.) на перечисление аргументов вывода через запятую (,), что вроде бы значительно экономит память.
Хотя реально экономия мизерная, которая особенно заметна на больших объемах данных.
Например, при таком вызове присваивания данных: $s = '2mb'; echo 'string' . $s; - будет израсходовано 4mb памяти, но для ситуации со строками, не превышающими килобайта
(а это уже тысяча знаков, что более чем покрывает все нужды), нужно будет выделить всего лишь 2 кб памяти, что не превысит максимальный буфер, а если и превысит, то всего
на 1 кб!

В-третьих, грамотно формировать вызов echo, сначала подготавливая строку

В-четвертых (а может и в самых первых), нужно стандартизировать большинство данных. Например, настроек модуля, чтобы не требовалось проверять наличие параметра в объекте,
а также чтобы неверное присвоение или добавление в объект выдавало ошибку.

===

проверить разные option/options
все param перевести в options